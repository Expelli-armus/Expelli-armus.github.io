<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2023/04/08/IF%20ANYTHING%20HAPENS%20I%20LOVE%20YOU/</url>
    <content><![CDATA[<hr>
<h1 id="IF-ANYTHING-HAPENS-I-LOVE-YOU"><a href="#IF-ANYTHING-HAPENS-I-LOVE-YOU" class="headerlink" title="IF ANYTHING HAPENS I LOVE YOU"></a>IF ANYTHING HAPENS I LOVE YOU</h1><p>真相，还是交给你自己去看。 谁也无法彻底走进别人的悲痛。 大多数时候，我们的感动和醒悟，都只是匆忙地掠过别人的一生。 但就是一眼。 也足以成为，彼此留存一生的信物。</p>
]]></content>
      <categories>
        <category>小记</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/01/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>00x1位运算</title>
    <url>/2023/08/03/00x1%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="00x1-位运算"><a href="#00x1-位运算" class="headerlink" title="00x1 位运算"></a>00x1 位运算</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">与</th>
<th style="text-align:center">或</th>
<th style="text-align:center">非</th>
<th style="text-align:center">异或</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td style="text-align:center">~</td>
<td>xor</td>
</tr>
</tbody>
</table>
</div>
<h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><p>左移:1&lt;&lt;n, n&lt;&lt;1</p>
<p>算数右移:向下取整（-3）&gt;&gt;1=-2, 3&gt;&gt;1=1</p>
<p>而整数/2在c++中实现“除以二向0取整”，即先取整再添加符号</p>
<h2 id="移位运算-1"><a href="#移位运算-1" class="headerlink" title="移位运算"></a>移位运算</h2><h3 id="64位整数乘法"><a href="#64位整数乘法" class="headerlink" title="64位整数乘法"></a>64位整数乘法</h3><p>求$a*b mod p$的值，其中$1\le a,b,p\le 10^{18}$。</p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>类似快速幂的思想</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll a,ll b,ll p)</span></span>&#123;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;b;b&gt;&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=(ans+a)%p;<span class="comment">//个位是奇数就直接加a</span></span><br><span class="line">		a=a*<span class="number">2</span>%p;<span class="comment">//将b的阶数转移到a上</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>利用$a<em>b mod p=a</em>b-\lfloor a<em>b/p\rfloor </em>p$(带余除法)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll a,ll b,ll c)</span></span>&#123;</span><br><span class="line">	a%=p;b%=p;</span><br><span class="line">    ll c=(ld)a*b/p;</span><br><span class="line">    ll ans=a*b-c*p;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;<span class="number">0</span>)ans+=p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ans&gt;=p)ans-=p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二进制状态压缩"><a href="#二进制状态压缩" class="headerlink" title="二进制状态压缩"></a>二进制状态压缩</h2><p>将一个长为m的bool数组用一个m位二进制整数表示并存储的办法。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>运算</th>
</tr>
</thead>
<tbody>
<tr>
<td>取第k位</td>
<td>(n&gt;&gt;k)&amp;1</td>
</tr>
<tr>
<td>取0~k-1位（即后k位）</td>
<td>n&amp;(1&lt;&lt;k-1)</td>
</tr>
<tr>
<td>第k位取反</td>
<td>n xor 1&lt;&lt;k</td>
</tr>
<tr>
<td>第k位赋值为1</td>
<td>n\</td>
<td>(1&lt;&lt;k)</td>
</tr>
<tr>
<td>第k位赋值为0</td>
<td>n&amp;(~(1&lt;&lt;k))</td>
</tr>
</tbody>
</table>
</div>
<h3 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a>最短Hamilton路径</h3><p>给定一张n($n\le 20$)个点的带权无向图，点从0~n-1标号，求起点0到终点n-1的最短Hamilton路径(从0到n-1经过每个点恰一次)。</p>
<p>很容易想到本题的一种“朴素”做法，即穷举，时间复杂度O(n<em>n!),利用二进制状态压缩DP可以优化到$O(n^2 </em>2^n)$。</p>
<p>用一个n位二进制数表示点的经过状态。用F[i,j]表示点的经过状态为i，且目前处于点j的最短路径。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f[<span class="number">1</span>&lt;&lt;<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hamilton</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> weight[<span class="number">20</span>][<span class="number">20</span>])</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;<span class="keyword">if</span>((i^<span class="number">1</span>&lt;&lt;j)&gt;&gt;k&amp;<span class="number">1</span>)</span><br><span class="line">                f[i][j]=<span class="built_in">min</span>(f[i][j],f[i^<span class="number">1</span>&lt;&lt;j][k]+weight[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">1</span>&lt;&lt;n<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例题-起床困难综合症"><a href="#例题-起床困难综合症" class="headerlink" title="[例题]起床困难综合症"></a>[例题]起床困难综合症</h3>]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
  </entry>
  <entry>
    <title>第一章 计算机系统概述</title>
    <url>/2023/10/25/ICS/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1>]]></content>
      <categories>
        <category>ICS</category>
      </categories>
  </entry>
  <entry>
    <title>第四章 程序的链接</title>
    <url>/2023/10/27/ICS/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ICS</category>
      </categories>
  </entry>
  <entry>
    <title>第三章 程序转换与机器级表示</title>
    <url>/2023/10/27/ICS/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ICS</category>
      </categories>
  </entry>
  <entry>
    <title>JH学习笔记</title>
    <url>/2023/10/25/JH%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="算法基础">2.3 算法基础</h1>
<h2 id="字母单词和语言">字母、单词和语言</h2>
<p>所有数据都以符号形式的字符串表示。数据表示的类型通常对算法实现的效率很重要。下面介绍一些形式语言理论的基础。我们不需要过多处理数据表示的细节，因为我们在抽象设计级别上考虑算法，通常不处理实现细节。本节的目标是给出一些定义来确定某些输入数据的表示，从而精确地形式化一些基本算法问题。</p>
<blockquote>
<ul>
<li>任意非空有限集合称为一个字母表。每个字母表<span
class="math inline">\(\sum\)</span>中的元素称为<span
class="math inline">\(\sum\)</span>的一个符号。</li>
<li><span
class="math inline">\(\sum\)</span>的符号组成的有限序列称为单词。0个符号组成空单词<span
class="math inline">\(\lambda\)</span>。</li>
<li><span class="math inline">\(\sum\)</span>生成的单词构成集合<span
class="math inline">\(\sum^*\)</span>。</li>
<li>单词<span class="math inline">\(w\)</span>的长度由<span
class="math inline">\(|w|\)</span>表示。</li>
<li>对每个<span class="math inline">\(a\in \sum\)</span>，<span
class="math inline">\(\#a(w)\)</span>表示<span
class="math inline">\(w\)</span>中<span
class="math inline">\(a\)</span>出现的次数。则<span
class="math display">\[|w|=\sum\#a(w)\]</span>。</li>
<li>对字母表<span class="math inline">\(\sum\)</span>，<span
class="math display">\[\sum^n=\{x\in\sum||x|=n\}\]</span>，即长度为n的单词构成的集合。</li>
<li>定义<span
class="math display">\[\sum^+=\sum^*-\{\lambda\}\]</span>。</li>
<li>对于字母表<span class="math inline">\(\sum\)</span>的两个单词<span
class="math inline">\(v,w\)</span>，<span
class="math inline">\(vw\)</span>为它们的连接。有<span
class="math display">\[w^0=\lambda,w^{n+1}=ww^n\]</span>。</li>
<li>如果<span class="math inline">\(w=uzv\)</span>,<span
class="math inline">\(u\)</span>称为<span
class="math inline">\(w\)</span>的前缀，<span
class="math inline">\(v\)</span>称为<span
class="math inline">\(w\)</span>的后缀，<span
class="math inline">\(z\)</span>称为<span
class="math inline">\(w\)</span>的子单词。</li>
<li>对字母表<span class="math inline">\(\sum\)</span>，对<span
class="math inline">\(L\subset \sum^*\)</span>，称<span
class="math inline">\(L\)</span>是<span
class="math inline">\(\sum\)</span>的语言。<span
class="math inline">\(L^c\)</span>称为<span
class="math inline">\(\sum\)</span>下语言<span
class="math inline">\(L\)</span>的补。</li>
<li><span class="math display">\[L_1L_2=\{uv|u\in L_1,v\in
L_2\}\]</span>称为语言的链接。</li>
<li>给出<span
class="math display">\[\sum=\{s_1,s_2,...,s_m\},s_1&lt;s_2&lt;...&lt;s_m\]</span>，则可给出单词的规范排序。先按长度排，长度相同的按照字母的大小排。</li>
</ul>
</blockquote>
<h2 id="算法问题">算法问题</h2>
<p>每个算法都可以看做字母表与字母表的映射。我们从决策问题开始，如果<span
class="math inline">\(A\)</span>是算法，<span
class="math inline">\(x\)</span>是输入，则<span
class="math inline">\(A(x)\)</span>表示输出。</p>
<h3 id="lusigma问题"><span
class="math inline">\(L,U,\Sigma\)</span>问题</h3>
<blockquote>
<p>决策问题：三元组<span
class="math inline">\((L,U,\Sigma)\)</span>确定的<span
class="math inline">\(U\rightarrow \{0,1\}\)</span>的函数。其中<span
class="math inline">\(L\subset U\subset \Sigma^*\)</span>。</p>
<p>Input:<span class="math inline">\(x\in U\)</span>.</p>
<p>Output:<span class="math inline">\(1,x\in L;0,x\notin L.\)</span></p>
<p>在很多问题中<span
class="math inline">\(U=\Sigma\)</span>，此时表示为<span
class="math inline">\((L,\Sigma)\)</span>问题。</p>
</blockquote>
<h4 id="素数测试">素数测试</h4>
<p><span
class="math inline">\((Prim,\Sigma_{bool})\)</span>问题。这是二进制的素数检测，可以通过改变字母表得到k进制的素数检测。</p>
<h4 id="判断相等">判断相等</h4>
<h5 id="eq-pol">EQ-POL</h5>
<blockquote>
<p>Input:素数p，由<span
class="math display">\[X=\{x_1,x_2,...,x_n\}\]</span>生成的两个多项式<span
class="math display">\[p_1,p_2\]</span>。</p>
<p>Output:在<span class="math inline">\(\mathbb{Z}_p\)</span>上<span
class="math display">\[p_1\equiv p_2\]</span>则输出1，否则输出0。</p>
</blockquote>
<h5 id="eq-1bp">EQ-1BP</h5>
<p>对两个给定的一次性分支程序，两者是否表示相同的布尔函数。</p>
<blockquote>
<p>Input:由布尔变量<span
class="math display">\[X=\{x_1,x_2,...,x_n\}\]</span>给出的布尔函数<span
class="math display">\[B_1,B_2\]</span>。</p>
<p>Output:相等为1，不等为0。</p>
</blockquote>
<h4 id="可满足性">可满足性</h4>
<p><a href="https://zhuanlan.zhihu.com/p/432853785">SAT问题简介 - 知乎
(zhihu.com)</a></p>
<p>设k为一个SAT问题中所有子句的长度上限，称以k为子句长度上限构成的SAT问题为k-SAT问题。</p>
<h4 id="分团问题">分团问题</h4>
<blockquote>
<p>Input: k,G。</p>
<p>Output: G中有<span
class="math inline">\(K_k\)</span>为1，否则为0。</p>
</blockquote>
<h3 id="顶点覆盖问题vcp">顶点覆盖问题(VCP)</h3>
<blockquote>
<p><strong>顶点覆盖 (Vertex Cover):</strong></p>
<p>给定一个无向图G，找到无向图G的点集子集V，使得无向图G中的任何一条边，都与点集子集V的至少一个节点是接触的。</p>
<p><strong>顶点覆盖问题:</strong>
查看无向图G中是否包含一个大小为k满足上述要求的点集子集V。</p>
</blockquote>
<p><span class="math inline">\((VCP,\{0,1,\# \})\)</span>问题。</p>
<p><span class="math display">\[VCP=\{u\#w\in\{0,1,\# \}^+|u\in
\{0,1\}^+且w为一张图存在大小为Number(u)的顶点覆盖 \}\]</span>。</p>
<h3 id="哈密顿回路">哈密顿回路</h3>
<p><span class="math inline">\((HC,\{0,1,\# \})\)</span>问题。</p>
<p><span class="math display">\[HC=\{ w\in\{0,1,\#
\}^*|w代表一张有哈密顿回路的图 \}\]</span>。</p>
<h4 id="线性规划解的存在性">线性规划解的存在性</h4>
<p><span class="math inline">\(AX=b\)</span>是否有解的问题。</p>
<p>直接给出最终版本：有限域上的线性规划整数解。</p>
<p><span class="math display">\[(Sol-IP_p,\{0,1,...,p-1,\# \}
)\]</span>问题。</p>
<p><span class="math display">\[Sol-IP_p=\{
&lt;A,b&gt;\in\{0,1,...,p-1,\# \} | \exist X,s.t. AX=b,\\其中
A是\mathbb{Z}_p上的m\times n矩阵,m、n为正整数，b\in
(\mathbb{Z}_p)^m，X\in (\mathbb{Z}_p)^n. \}\]</span></p>
<h1 id="分支界定">3.4 分支界定</h1>
<p><a
href="https://www.jianshu.com/p/c738c8262087">分支限界法——对解空间的一种策略搜索（广度优先搜索）
- 简书 (jianshu.com)</a></p>
<p>求解一个约束条件较多的问题A,可以暂缓考虑部分条件，变换成问题B,先求B的最优解（解松弛问题）。B的最优解一定比
A的好（或相当）。再将原来暂缓考虑的部分条件逐步插入问题B中，得到B的若干子问题，称为<strong>分枝</strong>。求解这些子问题，淘汰较差的解，直到所有暂缓考虑的部分条件全部插入为止。这时求得的最优解就是问题A的最优解。</p>
<h1 id="局部搜索">3.6 局部搜索</h1>
<p><a
href="https://blog.csdn.net/weixin_45526117/article/details/128018731">Discrete
Optimization课程笔记(3)—局部搜索_bujbujbiu的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>JH</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2023/11/15/%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<hr />
<h2 id="算法">算法</h2>
<p><a href="https://zhuanlan.zhihu.com/p/105467597">算法学习笔记（目录）
- 知乎 (zhihu.com)</a></p>
<p><a
href="https://zhuanlan.zhihu.com/p/467270686">旅行商(TSP)问题求解算法合集
- 知乎 (zhihu.com)</a></p>
<h2 id="物理">物理</h2>
<p><a
href="https://zhuanlan.zhihu.com/p/452443183">大物（下）-电磁学例题笔记
- 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/168770929">大学物理复习：电磁学
- 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>链接</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2023/09/29/%E6%95%B0%E7%94%B5%E5%AE%9E%E9%AA%8C/Lab2%20%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>tags: []</p>
<p>title: Lab2 时序逻辑电路实验</p>
<p>categories:</p>
<ul>
<li>数电实验</li>
</ul>
<h1 id="lab2-时序逻辑电路实验">Lab2 时序逻辑电路实验</h1>
<blockquote>
<p><strong>221240083 陈正佺</strong></p>
</blockquote>
<h2 id="寄存器堆设计">寄存器堆设计</h2>
<h3 id="实验整体方案设计">实验整体方案设计</h3>
<p>首先通过地址访问的方法构建32位寄存器堆，接着考虑我们FPGA板的情况考虑引脚的设计与输入模块</p>
<h3 id="子模块原理说明">子模块原理说明</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230929103033592.png" alt="image-20230929103033592" style="zoom:67%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230929103049152.png" alt="image-20230929103049152" style="zoom:50%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230929103538085.png" alt="image-20230929103538085" style="zoom: 50%;" /></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//寄存器堆模块</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    registers[<span class="number">0</span>]&lt;=<span class="number">32&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">if</span> (we&amp;&amp;rw!=<span class="number">5&#x27;b0</span>) <span class="keyword">begin</span></span><br><span class="line">      registers[rw] &lt;= busw;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">assign</span> busa=registers[ra];</span><br><span class="line">  <span class="keyword">assign</span> busb=registers[rb];</span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入匹配模块</span></span><br><span class="line">  regfile32 regfile32_check(<span class="variable">.busa</span>(busa32),<span class="variable">.busb</span>(busb32),<span class="variable">.busw</span>(busw32),<span class="variable">.ra</span>(ra32),<span class="variable">.rb</span>(rb32),<span class="variable">.rw</span>(rw32),<span class="variable">.clk</span>(clk),<span class="variable">.we</span>(we));</span><br><span class="line">  <span class="keyword">assign</span> busa8 = busa32[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">assign</span> busb8 = busb32[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">assign</span> busw32 = &#123;<span class="number">8</span>&#123;busw&#125;&#125;;</span><br><span class="line">  <span class="keyword">assign</span> ra32 = &#123;rd_hi, ra&#125;;</span><br><span class="line">  <span class="keyword">assign</span> rb32 = &#123;rd_hi, rb&#125;;</span><br><span class="line">  <span class="keyword">assign</span> rw32 = &#123;rd_hi, rw&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="仿真测试">仿真测试</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230929103343412.png" alt="image-20230929103343412" style="zoom:50%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230929103409042.png" alt="image-20230929103409042" style="zoom:50%;" /></p>
<p>可知电路满足设计需求。</p>
<h3 id="fpga验证">FPGA验证</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230929104124073.png" alt="image-20230929104124073" style="zoom: 10%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230929104158754.png" alt="image-20230929104158754" style="zoom:10%;" /></p>
<h4 id="错误现象及分析">错误现象及分析</h4>
<p>注意设置0号寄存器的值始终是0。</p>
<h2 id="比特流加密实验">比特流加密实验</h2>
<h3 id="实验整体方案设计-1">实验整体方案设计</h3>
<p>需要随机二进制流生成模块lfsr，二进流反馈模块和加密解密模块。</p>
<h3 id="子模块原理说明-1">子模块原理说明</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二进制流随机生成与载入模块</span></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(load)<span class="keyword">begin</span></span><br><span class="line">dout&lt;=seed;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!load) <span class="keyword">begin</span></span><br><span class="line"><span class="comment">//反馈方程</span></span><br><span class="line">dout&lt;=&#123;dout[<span class="number">0</span>]^dout[<span class="number">1</span>]^dout[<span class="number">3</span>]^dout[<span class="number">4</span>],dout[<span class="number">63</span>:<span class="number">1</span>]&#125;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加密模块</span></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(load)<span class="keyword">begin</span></span><br><span class="line">t&lt;=<span class="number">3&#x27;d0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!load)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">3&#x27;d5</span>)<span class="keyword">begin</span></span><br><span class="line">t&lt;=<span class="number">3&#x27;d0</span>;</span><br><span class="line">ready&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">key&lt;=dout[<span class="number">63</span>:<span class="number">58</span>];</span><br><span class="line">dataout&lt;=&#123;<span class="number">2&#x27;b01</span>,dout[<span class="number">63</span>:<span class="number">58</span>]^datain[<span class="number">5</span>:<span class="number">0</span>]&#125;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3&#x27;d0</span>)<span class="keyword">begin</span></span><br><span class="line">t&lt;=<span class="number">3&#x27;d1</span>;</span><br><span class="line">ready&lt;=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3&#x27;d1</span>)t&lt;=<span class="number">3&#x27;d2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3&#x27;d2</span>)t&lt;=<span class="number">3&#x27;d3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3&#x27;d3</span>)t&lt;=<span class="number">3&#x27;d4</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3&#x27;d4</span>)t&lt;=<span class="number">3&#x27;d5</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230929105101339.png" alt="image-20230929105101339" style="zoom:33%;" /></p>
<h3 id="仿真测试-1">仿真测试</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230929105204106.png" alt="image-20230929105204106" style="zoom:57%;" /></p>
<p>可知电路满足设计要求。</p>
<h3 id="fpga验证-1">FPGA验证</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230929105623977.png" alt="image-20230929105623977" style="zoom:15%;" />
<img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230929105703002.png" alt="image-20230929105703002" style="zoom:15%;" /></p>
<h4 id="错误现象及分析-1">错误现象及分析</h4>
<p>注意阻态与非阻态符号的区别，不要错误的计算为第7,13...周期的密码。</p>
<h2 id="数字时钟实验">数字时钟实验</h2>
<h3 id="实验整体方案设计-2">实验整体方案设计</h3>
<p>实现一个数字时钟，在七段数码管上分别显示 2
位十进制数的时、分、秒。要求能够复位；可以设置初始时间；整点报时，闪烁点亮三色
LED
灯。因此我们需要分频模块得到1HZ的计数器，7段码模块进行4位BCD码和7段数码管的转换，并引用计数器文件进行计数，最后实现led模块。</p>
<h3 id="子模块原理说明-2">子模块原理说明</h3>
<h4 id="分频模块">分频模块</h4>
<p>利用群文件的分频器，设置两个clk，一个为1Hz用于计数，另一个为1000Hz，使得7段数码管不停闪烁以达到6个数码管“同时”显示的效果。</p>
<h4 id="段数码管模块">7段数码管模块</h4>
<p>这里直接引用lab1的模块即可。</p>
<h4 id="计数器模块">计数器模块</h4>
<p>pdf上面有介绍。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @ (input_seconds) <span class="keyword">begin</span></span><br><span class="line">    seconds_remaining = input_seconds;</span><br><span class="line">    hour = seconds_remaining / <span class="number">3600</span>;</span><br><span class="line">    seconds_remaining = seconds_remaining - hour * <span class="number">3600</span>;</span><br><span class="line">    minute = seconds_remaining / <span class="number">60</span>;</span><br><span class="line">    seconds_remaining = seconds_remaining - minute * <span class="number">60</span>;</span><br><span class="line">    second = seconds_remaining;</span><br><span class="line">    <span class="comment">//接下来确定十位和个位</span></span><br><span class="line">    hour_tens = hour / <span class="number">10</span>;</span><br><span class="line">    hour_ones = hour - hour_tens * <span class="number">10</span>;</span><br><span class="line">    minute_tens = minute / <span class="number">10</span>;</span><br><span class="line">    minute_ones = minute - minute_tens * <span class="number">10</span>;</span><br><span class="line">    second_tens = second / <span class="number">10</span>;</span><br><span class="line">    second_ones = second - second_tens * <span class="number">10</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="主模块">主模块</h4>
<p>主要以正确的逻辑将上面的模块合理拼接。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> rst <span class="keyword">or</span> <span class="keyword">posedge</span> sclk)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(rst == <span class="number">1</span>) <span class="keyword">begin</span> seccount = <span class="number">17&#x27;b0</span>;countdown = <span class="number">4&#x27;b0000</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i = i+<span class="number">1</span>) begintimes[i] = pre_times[i];<span class="keyword">end</span> <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="number">2&#x27;b00</span>)<span class="keyword">begin</span> </span><br><span class="line">            seccount = (seccount &gt; <span class="number">17&#x27;d86398</span>) ? <span class="number">17&#x27;d0</span> : (seccount + <span class="number">1</span>);</span><br><span class="line">            times[<span class="number">7</span>] &lt;= pre_times[<span class="number">7</span>];times[<span class="number">6</span>] &lt;= pre_times[<span class="number">6</span>];times[<span class="number">4</span>] &lt;= pre_times[<span class="number">4</span>];</span><br><span class="line">            times[<span class="number">3</span>] &lt;= pre_times[<span class="number">3</span>];times[<span class="number">1</span>] &lt;= pre_times[<span class="number">1</span>];times[<span class="number">0</span>] &lt;= pre_times[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(times[<span class="number">4</span>] == <span class="number">5</span> &amp; times[<span class="number">3</span>] == <span class="number">9</span> &amp; times[<span class="number">1</span>] == <span class="number">5</span> &amp; times[<span class="number">0</span>] == <span class="number">9</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(times[<span class="number">7</span>] == <span class="number">2</span> &amp; times[<span class="number">6</span>] == <span class="number">3</span>) countdown = <span class="number">4&#x27;d11</span>;</span><br><span class="line">                <span class="keyword">else</span>   countdown = <span class="number">4&#x27;d7</span>;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="number">2&#x27;b01</span>) <span class="keyword">begin</span> <span class="comment">//表示设置小时的高位和低位</span></span><br><span class="line">            times[<span class="number">7</span>] &lt;= data_h; times[<span class="number">6</span>] &lt;= data_l;</span><br><span class="line">            seccount &lt;= data_h * <span class="number">36000</span> + data_l * <span class="number">3600</span> + times[<span class="number">4</span>] * <span class="number">600</span> + times[<span class="number">3</span>] * <span class="number">60</span> + times[<span class="number">1</span>] * <span class="number">10</span> + times[<span class="number">0</span>];<span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="number">2&#x27;b10</span>) <span class="keyword">begin</span> <span class="comment">//设置分钟</span></span><br><span class="line">            times[<span class="number">4</span>] &lt;= data_h; times[<span class="number">3</span>] &lt;= data_l;</span><br><span class="line">            seccount &lt;= times[<span class="number">7</span>] * <span class="number">36000</span> + times[<span class="number">6</span>] * <span class="number">3600</span> + data_h * <span class="number">600</span> + data_l * <span class="number">60</span> + times[<span class="number">1</span>] * <span class="number">10</span> + times[<span class="number">0</span>];<span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">//设置秒</span></span><br><span class="line">            times[<span class="number">1</span>] &lt;= data_h; times[<span class="number">0</span>] &lt;= data_l;</span><br><span class="line">            seccount &lt;= times[<span class="number">7</span>] * <span class="number">36000</span> + times[<span class="number">6</span>] * <span class="number">3600</span> + times[<span class="number">4</span>] * <span class="number">600</span> + times[<span class="number">3</span>] * <span class="number">60</span> + data_h * <span class="number">10</span> + data_l;<span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>(countdown != <span class="number">4&#x27;b0</span>) countdown = countdown-<span class="number">1</span>;<span class="keyword">end</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230929111038093.png" alt="image-20230929111038093" style="zoom:47%;" /></p>
<h3 id="fpga验证-2">FPGA验证</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230929111733844.png" alt="image-20230929111733844" style="zoom:25%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230929111815891.png" alt="image-20230929111815891" style="zoom:25%;" /></p>
<h4 id="错误现象及分析-2">错误现象及分析</h4>
<p>注意频率过快人眼是看不到的，因此不能用100mHz来进行7段码的闪烁。</p>
<h2 id="思考题">思考题</h2>
<p>1.<strong>分析32个32位的寄存器堆占用的逻辑片资源。</strong></p>
<p>我们的寄存器堆是由D触发器建立的，32个D触发器构成一个32位寄存器，每个D触发器需要使用4个逻辑片资源。那么32个32位的寄存器堆将需要占用逻辑片资源为<span
class="math inline">\(32*32*4=4096\)</span>。</p>
<p>2.<strong>分析 64
位移位寄存器的时序性能和资源占用情况；并通过资料查找到其他的生成 LFSR
的反馈公式。</strong></p>
<p>移位寄存器通常通过把低位 D 触发器输出接入到高位 D
触发器输入端来实现。第一个D触发器接收输入数据，随着时钟的上升沿，数据从第一位开始被逐位传递到下一个D触发器，直到到达最高位D触发器。当时钟信号发生上升沿时，最低位的数据被移位到仅次于它的位，最终推出寄存器，然后新的数据被输入到最低位的D触发器，以此类推。</p>
<p>因为每一位的移位操作是顺序进行的，不需要复杂的逻辑电路。时序性能主要由时钟频率和触发器延迟等因素决定。由于使用了级联连接，资源占用相对较小，只需要64个D触发器和连接它们的信号线。在移位操作中，由于每一位之间是独立的，可以实现并行的移位操作，提高了性能。</p>
<p>因此，使用级联的D触发器连接的64位移位寄存器具有较好的时序性能和较小的资源占用情况。</p>
<p>斐波那契LFSR:</p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230929113705696.png" alt="image-20230929113705696" style="zoom: 50%;" /></p>
<p>伽罗瓦LFSR:</p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230929114210099.png" alt="image-20230929114210099" style="zoom:53%;" /></p>
<p>3.<strong>数字时钟中如何实现倒计时和毫秒计时器功能。</strong></p>
<p>倒计时：</p>
<p>使用一个计数器变量来表示倒计时的时间，以秒为单位。</p>
<p>在每秒钟的时钟脉冲到来时，将计数器变量减1。</p>
<p>当计数器变量减至0时，停止倒计时并触发相应的事件。</p>
<p>将计数器变量的值以合适的格式显示在数字时钟上。</p>
<p>毫秒计时：</p>
<p>使用分频器得到1ms的时间间隔。</p>
<p>使用一个计数器变量来表示毫秒计时器的时间，以毫秒为单位。</p>
<p>在每毫秒的时钟脉冲到来时，将计数器变量加1。</p>
<p>将计数器变量的值以合适的格式显示在数字时钟上。</p>
<p>考虑到显示器刷新的速度，可以选择每秒更新一次显示器，将计数器变量的值转换为秒和毫秒的格式，显示在数字时钟上。</p>
]]></content>
  </entry>
  <entry>
    <title>Lab1 4路3位数据传输实验</title>
    <url>/2023/09/12/%E6%95%B0%E7%94%B5%E5%AE%9E%E9%AA%8C/Lab1%204%E8%B7%AF3%E4%BD%8D%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="lab1组合逻辑电路实验">Lab1：组合逻辑电路实验</h1>
<h4 id="陈正佺">221240083 陈正佺</h4>
<h2 id="一4路3位数据传输实验">一、4路3位数据传输实验</h2>
<h3 id="实验整体方案设计">实验整体方案设计</h3>
<p>我们要实现4路3位数据传输，而多路选择器和多路分配器级联使用可以实现多通道数据的分时传送。在发送端通过多路选择器将各路数据分时送到总线，接收端再由多路分配器将总线上的数据适时分配到相应的输出端，从而传送到目的部件。</p>
<figure>
<img
src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230912163910067.png"
alt="image-20230912163910067" />
<figcaption aria-hidden="true">image-20230912163910067</figcaption>
</figure>
<h3 id="实验说明">实验说明</h3>
<h4 id="多路选择器模块">多路选择器模块</h4>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230912164032437.png" alt="image-20230912164032437" style="zoom:50%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module mux4to1_2( //端口声明</span><br><span class="line">output y, // 声明 1 个 wire 型输出变量 y，其宽度为 1 位。</span><br><span class="line">input d0, d1,d2,d3, // 声明 4 个 wire 型输入变量 d0-d3，其宽度为 1 位。</span><br><span class="line">input s0, s1 // 声明 2 个 wire 型输入变量 s0、s1，其宽度为 1 位。</span><br><span class="line">); </span><br><span class="line">assign y =  (s0) ? (s1 ? d3 : d2) : (s1 ? d1 : d0);</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<h4 id="多路分配器模块">多路分配器模块</h4>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230912164239726.png" alt="image-20230912164239726" style="zoom: 67%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module dmux1to4(</span><br><span class="line">//端口声明</span><br><span class="line">output [3:0] d0,d1,d2,d3， //4 路 4 位的输出信号 d0~d3。</span><br><span class="line">input [3:0] d, // 4 位输入信号 d。</span><br><span class="line">input [1:0] s // 2 位选择控制信号 s。</span><br><span class="line">); </span><br><span class="line"> assign d0 = ( ~s[1] &amp; ~s[0] ) ? d : 4 &#x27;bz;</span><br><span class="line"> assign d1 = ( ~s[1] &amp; s[0] ) ? d : 4&#x27;bz;</span><br><span class="line"> assign d2 = ( s[1] &amp; ~s[0] ) ? d : 4&#x27;bz;</span><br><span class="line">assign d3 = ( s[1] &amp; s[0] ) ? d : 4&#x27;bz;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<h4 id="实验设计">实验设计</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module trans4to4(</span><br><span class="line">    output  [2:0] Y0,Y1,Y2,Y3,</span><br><span class="line">    input   [2:0] D0,D1,D2,D3,</span><br><span class="line">    input   [1:0] S</span><br><span class="line">); </span><br><span class="line">// add your code here</span><br><span class="line">wire [2:0]y;</span><br><span class="line">assign y[0] = (S[0]) ? (S[1] ? D3[0] : D2[0]) : (S[1] ? D1[0] : D0[0]);</span><br><span class="line">assign y[1] = (S[0]) ? (S[1] ? D3[1] : D2[1]) : (S[1] ? D1[1] : D0[1]);</span><br><span class="line">assign y[2] = (S[0]) ? (S[1] ? D3[2] : D2[2]) : (S[1] ? D1[2] : D0[2]);</span><br><span class="line">assign Y0 = ( ~S[1] &amp; ~S[0] ) ? y : 3&#x27;bz;</span><br><span class="line">assign Y1 = ( ~S[1] &amp; S[0] ) ? y : 3&#x27;bz;</span><br><span class="line">assign Y2 = ( S[1] &amp; ~S[0] ) ? y : 3&#x27;bz;</span><br><span class="line">assign Y3 = ( S[1] &amp; S[0] ) ? y : 3&#x27;bz;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230912165122167.png" alt="image-20230912165122167" style="zoom:50%;" /></p>
<h3 id="实验数据仿真测试">实验数据仿真测试</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230912164742184.png" alt="image-20230912164742184" style="zoom:50%;" /><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230912164806181.png" alt="image-20230912164806181" style="zoom: 67%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230912164827598.png" alt="image-20230912164827598" style="zoom: 67%;" /><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230912164855957.png" alt="image-20230912164855957" style="zoom:67%;" /></p>
<p>由仿真测试可知，电路满足设计要求。</p>
<h3 id="实验验证">实验验证</h3>
<p>执行设计综合，生产比特流文件，下载到开发板。</p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230912165355056.png" alt="image-20230912165355056" style="zoom:50%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916144459927.png" alt="image-20230916144459927" style="zoom: 15%;" /><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916144516935.png" alt="image-20230916144516935" style="zoom: 15%;" /><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916144459927.png" alt="image-20230916144459927" style="zoom: 15%;" /><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916144516935.png" alt="image-20230916144516935" style="zoom: 15%;" /></p>
<p>​</p>
<h3 id="错误现象及分析">错误现象及分析</h3>
<p>注意assign的使用条件。</p>
<h2 id="二七段数码管实验">二、七段数码管实验</h2>
<h3 id="实验整体方案设计-1">实验整体方案设计</h3>
<p>要实现7位数码管，我们用I来控制字母形状，用S来控制具体哪个数码管被点亮。</p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916143417247.png" alt="image-20230916143417247" style="zoom:33%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916143914393.png" alt="image-20230916143914393" style="zoom:50%;" /></p>
<h3 id="实验说明-1">实验说明</h3>
<h4 id="i来控制字母形状">I来控制字母形状</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">always @ (I)</span><br><span class="line">case (I)</span><br><span class="line">4&#x27;b0000: O_seg = 7&#x27;b1000000;</span><br><span class="line">4&#x27;b1000: O_seg = 7&#x27;b1111001;</span><br><span class="line">4&#x27;b0100: O_seg = 7&#x27;b0100100;</span><br><span class="line">4&#x27;b1100: O_seg = 7&#x27;b0110000;</span><br><span class="line">4&#x27;b0010: O_seg = 7&#x27;b1001100;</span><br><span class="line">4&#x27;b1010: O_seg = 7&#x27;b0010010;</span><br><span class="line">4&#x27;b0110: O_seg = 7&#x27;b0100000;</span><br><span class="line">4&#x27;b1110: O_seg = 7&#x27;b1111000;</span><br><span class="line">4&#x27;b0001: O_seg = 7&#x27;b0000000;</span><br><span class="line">4&#x27;b1001: O_seg = 7&#x27;b0010000;</span><br><span class="line">4&#x27;b0101: O_seg = 7&#x27;b0001000;</span><br><span class="line">4&#x27;b1101: O_seg = 7&#x27;b0000011;</span><br><span class="line">4&#x27;b0011: O_seg = 7&#x27;b1000110;</span><br><span class="line">4&#x27;b1011: O_seg = 7&#x27;b0100001;</span><br><span class="line">4&#x27;b0111: O_seg = 7&#x27;b0000110;</span><br><span class="line">4&#x27;b1111: O_seg = 7&#x27;b0001110;</span><br><span class="line">endcase</span><br></pre></td></tr></table></figure>
<h4 id="s来控制数码管">S来控制数码管</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">always @ (S)</span><br><span class="line">case (S)</span><br><span class="line"> 3&#x27;b000: O_led = 8&#x27;b11111110;</span><br><span class="line"> 3&#x27;b001: O_led = 8&#x27;b11111101;</span><br><span class="line"> 3&#x27;b010: O_led = 8&#x27;b11111011;</span><br><span class="line"> 3&#x27;b011: O_led = 8&#x27;b11110111;</span><br><span class="line"> 3&#x27;b100: O_led = 8&#x27;b11101111;</span><br><span class="line"> 3&#x27;b101: O_led = 8&#x27;b11011111;</span><br><span class="line"> 3&#x27;b110: O_led = 8&#x27;b10111111;</span><br><span class="line"> 3&#x27;b111: O_led = 8&#x27;b01111111;</span><br><span class="line"> endcase</span><br></pre></td></tr></table></figure>
<h4 id="实验设计-1">实验设计</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module dec7seg(</span><br><span class="line">//端口声明</span><br><span class="line">output  reg  [6:0] O_seg,  //7位显示段输出</span><br><span class="line">output  reg  [7:0] O_led,  //8个数码管输出控制</span><br><span class="line">input   [3:0] I,           //4位数据输入，需要显示的数字   </span><br><span class="line">input   [2:0] S          //3位译码选择指定数码管显示</span><br><span class="line">); </span><br><span class="line">// add your code here</span><br><span class="line"></span><br><span class="line">always @ (S)</span><br><span class="line">case (S)</span><br><span class="line"> 3&#x27;b000: O_led = 8&#x27;b11111110;</span><br><span class="line"> 3&#x27;b001: O_led = 8&#x27;b11111101;</span><br><span class="line"> 3&#x27;b010: O_led = 8&#x27;b11111011;</span><br><span class="line"> 3&#x27;b011: O_led = 8&#x27;b11110111;</span><br><span class="line"> 3&#x27;b100: O_led = 8&#x27;b11101111;</span><br><span class="line"> 3&#x27;b101: O_led = 8&#x27;b11011111;</span><br><span class="line"> 3&#x27;b110: O_led = 8&#x27;b10111111;</span><br><span class="line"> 3&#x27;b111: O_led = 8&#x27;b01111111;</span><br><span class="line"> endcase</span><br><span class="line">always @ (I)</span><br><span class="line">case (I)</span><br><span class="line">4&#x27;b0000: O_seg = 7&#x27;b1000000;</span><br><span class="line">4&#x27;b1000: O_seg = 7&#x27;b1111001;</span><br><span class="line">4&#x27;b0100: O_seg = 7&#x27;b0100100;</span><br><span class="line">4&#x27;b1100: O_seg = 7&#x27;b0110000;</span><br><span class="line">4&#x27;b0010: O_seg = 7&#x27;b1001100;</span><br><span class="line">4&#x27;b1010: O_seg = 7&#x27;b0010010;</span><br><span class="line">4&#x27;b0110: O_seg = 7&#x27;b0100000;</span><br><span class="line">4&#x27;b1110: O_seg = 7&#x27;b1111000;</span><br><span class="line">4&#x27;b0001: O_seg = 7&#x27;b0000000;</span><br><span class="line">4&#x27;b1001: O_seg = 7&#x27;b0010000;</span><br><span class="line">4&#x27;b0101: O_seg = 7&#x27;b0001000;</span><br><span class="line">4&#x27;b1101: O_seg = 7&#x27;b0000011;</span><br><span class="line">4&#x27;b0011: O_seg = 7&#x27;b1000110;</span><br><span class="line">4&#x27;b1011: O_seg = 7&#x27;b0100001;</span><br><span class="line">4&#x27;b0111: O_seg = 7&#x27;b0000110;</span><br><span class="line">4&#x27;b1111: O_seg = 7&#x27;b0001110;</span><br><span class="line">endcase</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916145242754.png" alt="image-20230916145242754" style="zoom:67%;" /></p>
<h3 id="实验数据仿真测试-1">实验数据仿真测试</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916143637557.png" alt="image-20230916143637557" style="zoom: 80%;" /><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916143653876.png" alt="image-20230916143653876" /><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916143653876.png" alt="image-20230916143653876" style="zoom: 80%;" /><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916143653876.png" alt="image-20230916143653876" /><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916143653876.png" alt="image-20230916143653876" style="zoom: 80%;" /></p>
<h3 id="实验验证-1">实验验证</h3>
<p>执行设计综合，生产比特流文件，下载到开发板。</p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916144945280.png" alt="image-20230916144945280" style="zoom:15%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916145008843.png" alt="image-20230916145008843" style="zoom:15%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916145028506.png" alt="image-20230916145028506" style="zoom:15%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916145055193.png" alt="image-20230916145055193" style="zoom:15%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916145055193.png" alt="image-20230916145055193" style="zoom: 15%;" /></p>
<h3 id="错误现象及分析-1">错误现象及分析</h3>
<p>数码管是共阳极连接方式，如果给
数码管的某个引脚输入低电平则数码管会被点亮，若输入高电平则数码管变暗，如果在
FPGA 的 L3 端输出一个低电平 0，则数码管的 CA 段将 被点亮，FPGA
的这些输出端默认值为
0，如果不希望某段数码管点亮，必须对引脚输入“1”。要注意这一点，否则0和1颠倒的话，被选中的数码管不会点亮，其他7个数码管会点亮。</p>
<h2 id="三汉明码纠错实验">三、汉明码纠错实验</h2>
<h3 id="实验整体方案设计-2">实验整体方案设计</h3>
<p>分成三组获得三个故障编码，得到出错的位置并进行修改。</p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916180144398.png" alt="image-20230916180144398" style="zoom:50%;" /></p>
<h3 id="实验说明-2">实验说明</h3>
<h4 id="实验设计-2">实验设计</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module hamming7check(</span><br><span class="line">   output reg [7:1] DC,    //纠错输出7位正确的结果</span><br><span class="line">   output reg  NOERROR,    //校验结果正确标志位</span><br><span class="line">   input  [7:1] DU         //输入7位汉明码</span><br><span class="line">);</span><br><span class="line">// add your code here</span><br><span class="line"></span><br><span class="line">assign c=DU[3]^DU[5]^DU[7]^DU[1];</span><br><span class="line">assign b=DU[3]^DU[6]^DU[7]^DU[2];</span><br><span class="line">assign a=DU[5]^DU[6]^DU[7]^DU[4];</span><br><span class="line">always @(*)</span><br><span class="line">NOERROR=~(a|b|c);</span><br><span class="line"></span><br><span class="line">always @(a,b,c)</span><br><span class="line">if(~a&amp;~b&amp;c)begin//001</span><br><span class="line">DC[1]=~DU[1];DC[2]=DU[2];DC[3]=DU[3];DC[4]=DU[4];DC[5]=DU[5];DC[6]=DU[6];DC[7]=DU[7];</span><br><span class="line">end</span><br><span class="line">else if(~a&amp;~b&amp;~c)begin//000</span><br><span class="line">DC[1]=DU[1];DC[2]=DU[2];DC[3]=DU[3];DC[4]=DU[4];DC[5]=DU[5];DC[6]=DU[6];DC[7]=DU[7];</span><br><span class="line">end</span><br><span class="line">else if(~a&amp;b&amp;~c)begin//010</span><br><span class="line">DC[1]=DU[1];DC[2]=~DU[2];DC[3]=DU[3];DC[4]=DU[4];DC[5]=DU[5];DC[6]=DU[6];DC[7]=DU[7];</span><br><span class="line">end</span><br><span class="line">else if(~a&amp;b&amp;c)begin//011</span><br><span class="line">DC[1]=DU[1];DC[2]=DU[2];DC[3]=~DU[3];DC[4]=DU[4];DC[5]=DU[5];DC[6]=DU[6];DC[7]=DU[7];</span><br><span class="line">end</span><br><span class="line">else if(a&amp;~b&amp;~c)begin//100</span><br><span class="line">DC[1]=DU[1];DC[2]=DU[2];DC[3]=DU[3];DC[4]=~DU[4];DC[5]=DU[5];DC[6]=DU[6];DC[7]=DU[7];</span><br><span class="line">end</span><br><span class="line">else if(a&amp;~b&amp;c)begin//101</span><br><span class="line">DC[1]=DU[1];DC[2]=DU[2];DC[3]=DU[3];DC[4]=DU[4];DC[5]=~DU[5];DC[6]=DU[6];DC[7]=DU[7];</span><br><span class="line">end</span><br><span class="line">else if(a&amp;b&amp;~c)begin//110</span><br><span class="line">DC[1]=DU[1];DC[2]=DU[2];DC[3]=DU[3];DC[4]=DU[4];DC[5]=DU[5];DC[6]=~DU[6];DC[7]=DU[7];</span><br><span class="line">end</span><br><span class="line">else if(a&amp;b&amp;c)begin//111</span><br><span class="line">DC[1]=DU[1];DC[2]=DU[2];DC[3]=DU[3];DC[4]=DU[4];DC[5]=DU[5];DC[6]=DU[6];DC[7]=~DU[7];</span><br><span class="line">end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916182011214.png" alt="image-20230916182011214" style="zoom: 50%;" /></p>
<h3 id="实验数据仿真测试-2">实验数据仿真测试</h3>
<figure>
<img
src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916184048488.png"
alt="image-20230916184048488" />
<figcaption aria-hidden="true">image-20230916184048488</figcaption>
</figure>
<figure>
<img
src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916184109909.png"
alt="image-20230916184109909" />
<figcaption aria-hidden="true">image-20230916184109909</figcaption>
</figure>
<figure>
<img
src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916184130594.png"
alt="image-20230916184130594" />
<figcaption aria-hidden="true">image-20230916184130594</figcaption>
</figure>
<h3 id="实验验证-2">实验验证</h3>
<p>执行设计综合，生产比特流文件，下载到开发板。</p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916184154429.png" alt="image-20230916184154429" style="zoom:15%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916184217077.png" alt="image-20230916184217077" style="zoom:15%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916184235893.png" alt="image-20230916184235893" style="zoom:15%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20230916184259365.png" alt="image-20230916184259365" style="zoom:15%;" /></p>
<h3 id="错误现象及分析-2">错误现象及分析</h3>
<p>注意S3S2S1为故障位，而不是S1S2S3。</p>
<h2 id="四思考题">四、思考题</h2>
<h3 id="位比较器">32 位比较器</h3>
<p>我们采用数据流建模方式实现32位数值比较器，设计代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module compare_32(</span><br><span class="line">    input [31:0] P,</span><br><span class="line">    input [31:0] Q,</span><br><span class="line">    output PGTQ,</span><br><span class="line">    output PETQ,</span><br><span class="line">    output PLTQ</span><br><span class="line">    );</span><br><span class="line"> assign PGTQ = ( (P &gt; Q) ? 1&#x27;b1 : 1&#x27;b0 ) ;</span><br><span class="line"> assign PEQQ = ( (P == Q) ? 1&#x27;b1 : 1&#x27;b0 ) ;</span><br><span class="line"> assign PLTQ = ~PGTQ &amp; ~PEQQ; </span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<h3 id="位译码器">32 位译码器</h3>
<p>译码器是一种多输入、多输出组合逻辑电路，仿照3-8译码器，我们给出5-32译码器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module decode5_32(</span><br><span class="line">    input [4:0] In,</span><br><span class="line">    output [31:0] Out,</span><br><span class="line">    input En</span><br><span class="line">    );</span><br><span class="line">    assign Out =En ? (1&lt;&lt;In) : 0;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<h3 id="滚动显示">滚动显示</h3>
<p>我们需要添加一个时钟分频模块：用于产生定时信号，以控制数码管的滚动速度。并添加状态机模块用于控制学号的滚动操作。因此，我们创建一个计数器用于控制学号的滚动速度，并根据计数器的值更新当前要显示的学号片段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module DisplayScroll(</span><br><span class="line">    input wire clk,          // 输入时钟</span><br><span class="line">    output reg [7:0] seg,   // 数码管段选控制信号</span><br><span class="line">    output reg [7:0] dig    // 数码管位选控制信号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 时钟分频模块</span><br><span class="line">reg [23:0] counter = 0;</span><br><span class="line">reg clk_1hz = 0;</span><br><span class="line"></span><br><span class="line">always @(posedge clk) begin</span><br><span class="line">    if (counter == 24000000 - 1) begin   // 将 24000000 分频为 1Hz</span><br><span class="line">        counter &lt;= 0;</span><br><span class="line">        clk_1hz &lt;= ~clk_1hz;</span><br><span class="line">    end else</span><br><span class="line">        counter &lt;= counter + 1;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">// 状态机模块</span><br><span class="line">reg [3:0] digit = 0;</span><br><span class="line">reg [31:0] display_num = 32&#x27;h0221240083;  // 初始显示学号为 221240083</span><br><span class="line"></span><br><span class="line">always @(posedge clk_1hz) begin</span><br><span class="line">    case (digit)</span><br><span class="line">        0, 1, 2:   // 学号的前三个数字 2-2-1</span><br><span class="line">            begin</span><br><span class="line">                seg &lt;= display_num[27:24];</span><br><span class="line">                dig &lt;= ~(1 &lt;&lt; digit);</span><br><span class="line">                digit &lt;= digit + 1;</span><br><span class="line">            end</span><br><span class="line">        3,4,5,6,7,8,9:   // 滚动显示学号的后面数字（2-4-1-2-4-0-0-8-3）</span><br><span class="line">            begin</span><br><span class="line">                display_num &lt;= display_num &lt;&lt; 4;</span><br><span class="line">                seg &lt;= display_num[27:24];</span><br><span class="line">                dig &lt;= ~(1 &lt;&lt; digit);</span><br><span class="line">                digit &lt;= digit + 1;</span><br><span class="line">                if (digit == 10)  // 显示完最后一个数字后，重置为第一个数字</span><br><span class="line">                    digit &lt;= 0;</span><br><span class="line">            end</span><br><span class="line">    endcase</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<h3 id="位数据位的汉明码">8 位数据位的汉明码</h3>
<p>8位数据位M[8:1]时，通过计算得出需要4位校验位P[4:1]。类似7位汉明码纠错实验，得到公式：</p>
<p><span class="math display">\[
S[1]=DU[1]\bigoplus DU[3]\bigoplus DU[5]\bigoplus DU[7]\bigoplus
DU[9]\bigoplus DU[11]\\
S[2]=DU[2]\bigoplus DU[3]\bigoplus DU[6]\bigoplus DU[7]\bigoplus
DU[10]\bigoplus DU[11]\\
S[3]=DU[4]\bigoplus DU[5]\bigoplus DU[6]\bigoplus DU[7]\bigoplus
DU[10]\bigoplus DU[12]\\
S[4]=DU[8]\bigoplus DU[9]\bigoplus DU[10]\bigoplus DU[11]\bigoplus
DU[12]
\]</span> 据此编辑设计代码即可。</p>
]]></content>
      <categories>
        <category>数电实验</category>
      </categories>
  </entry>
  <entry>
    <title>Lab5 键盘鼠标接口实验</title>
    <url>/2023/10/28/%E6%95%B0%E7%94%B5%E5%AE%9E%E9%AA%8C/Lab5%20%E9%94%AE%E7%9B%98%E9%BC%A0%E6%A0%87%E6%8E%A5%E5%8F%A3%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="键盘鼠标接口实验">键盘鼠标接口实验</h1>
<blockquote>
<ul>
<li>221240083</li>
</ul>
</blockquote>
<h2 id="键盘接口实验">键盘接口实验</h2>
<h3 id="实验整体方案设计">实验整体方案设计</h3>
<p>键盘接口有按键消抖、去重、按键识别、键码产生几个基本功能。</p>
<p>此外7段码高两位显示当前计数，因此需要添加计数器。</p>
<h3 id="子模块设计">子模块设计</h3>
<p>KeyBoardReceiver模块是用来接收键盘送来的连续4个字节的键盘扫描码数据。</p>
<p>debouncer模块用来消除按键抖动。</p>
<p>kbcode2ascii模块实现根据扫描码查找对应ASCII码的功能。</p>
<p>我们7段码的中间4位记录上一次按键和当前按键，而松开则不做考虑，因此我们需要判断按下的情况并记录，可以用状态机实现。</p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231029102315432.png" alt="image-20231029102315432" style="zoom:33%;" /></p>
<p>按下则处于状态0，进行记录并去重，如果继续按下其他按键，则判断与之前的通码是否相同，若不同，则更新。一旦遇到f0，则转换为状态1，进入即将松开的状态，完全松开后，则回到状态0。状态1在我们判断shift是否松开的时候会用到。</p>
<p>此外还有缓冲区溢出检测。原本我们的输入直接传送到输出，没有缓冲区。现在我们添加一个一定长度的缓冲区，应用链表实现。此时，我们的输入会进入缓冲区，添加到缓冲区的尾端，使用键盘时钟。而缓冲区的数据会按照我们自定义的时钟传送到输出端，从链表表头取走数据，并更新表头。一旦链表中没有数据，则说明没有要传送的数据。一旦链表的长度超过我们预设的缓冲区范围，说明缓冲区溢出。这样我们就实现了缓冲区溢出。</p>
<h3 id="fpga验证">FPGA验证</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231029132832562.png" alt="image-20231029132832562" style="zoom:15%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231029132901904.png" alt="image-20231029132901904" style="zoom:15%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231029132915282.png" alt="image-20231029132915282" style="zoom:15%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231029132931523.png" alt="image-20231029132931523" style="zoom:15%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231029132950733.png" alt="image-20231029132950733" style="zoom:15%;" /></p>
<h3 id="错误现象及分析">错误现象及分析</h3>
<p>当按下A再松开A，接收模块接收到1c f0
1c，如果继续按下A，按照原来的接收模块会判断接下来的1c与上次断码中的1c相同，不会记录，因此需要修改接收器模块接收数据的判定条件。</p>
<h2 id="鼠标接口实验">鼠标接口实验</h2>
<h3 id="实验整体方案设计-1">实验整体方案设计</h3>
<p>类似键盘接受模块来接收鼠标数据。共4帧，分4帧来传送。</p>
<h3 id="子模块设计-1">子模块设计</h3>
<p>只需按照我们取得的数据将数据映射到7段码，显示x,y,z的数据和鼠标按键的按键情况即可。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">negedge</span>(PS2_CLK))<span class="keyword">begin</span></span><br><span class="line">     <span class="keyword">case</span>(cnt)</span><br><span class="line">            <span class="number">0</span>:  readyflag&lt;=<span class="number">1&#x27;b0</span>;                       <span class="comment">//开始位</span></span><br><span class="line">            <span class="number">1</span>:data[<span class="number">0</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">2</span>:data[<span class="number">1</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">3</span>:data[<span class="number">2</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">4</span>:data[<span class="number">3</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">5</span>:data[<span class="number">4</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">6</span>:data[<span class="number">5</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">7</span>:data[<span class="number">6</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">8</span>:data[<span class="number">7</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">9</span>:flag[<span class="number">0</span>]&lt;=<span class="number">1&#x27;b1</span>;         <span class="comment">//已接收8位有效数据</span></span><br><span class="line">            <span class="number">10</span>:flag[<span class="number">0</span>]&lt;=<span class="number">1&#x27;b0</span>;       <span class="comment">//结束位</span></span><br><span class="line">            <span class="number">11</span>: readyflag&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="number">12</span>:data[<span class="number">8</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">13</span>:data[<span class="number">9</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">14</span>:data[<span class="number">10</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">15</span>:data[<span class="number">11</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">16</span>:data[<span class="number">12</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">17</span>:data[<span class="number">13</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">18</span>:data[<span class="number">14</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">19</span>:data[<span class="number">15</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">20</span>:flag[<span class="number">1</span>]&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="number">21</span>:flag[<span class="number">1</span>]&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="number">22</span>: readyflag&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="number">23</span>:data[<span class="number">16</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">24</span>:data[<span class="number">17</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">25</span>:data[<span class="number">18</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">26</span>:data[<span class="number">19</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">27</span>:data[<span class="number">20</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">28</span>:data[<span class="number">21</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">29</span>:data[<span class="number">22</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">30</span>:data[<span class="number">23</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">31</span>:flag[<span class="number">2</span>]&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="number">32</span>:flag[<span class="number">2</span>]&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="number">33</span>: readyflag&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="number">34</span>:data[<span class="number">24</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">35</span>:data[<span class="number">25</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">36</span>:data[<span class="number">26</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">37</span>:data[<span class="number">27</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">38</span>:data[<span class="number">28</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">39</span>:data[<span class="number">29</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">40</span>:data[<span class="number">30</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">41</span>:data[<span class="number">31</span>]&lt;=kdataf;</span><br><span class="line">            <span class="number">42</span>:flag[<span class="number">3</span>]&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="number">43</span>:flag[<span class="number">3</span>]&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">          <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">if</span>(cnt&lt;=<span class="number">20</span>) cnt&lt;=cnt+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">21</span>&amp;&amp;SC)  <span class="keyword">begin</span> cnt&lt;=<span class="number">0</span>; SC&lt;=<span class="number">0</span>;<span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt&lt;=<span class="number">42</span>) cnt&lt;=cnt+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> cnt&lt;=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> X=&#123;data[<span class="number">4</span>],&#123;<span class="number">8</span>&#123;data[<span class="number">4</span>]&#125;&#125;^data[<span class="number">15</span>:<span class="number">8</span>]+data[<span class="number">4</span>]&#125;;</span><br><span class="line">    <span class="keyword">assign</span> Y=&#123;data[<span class="number">5</span>],&#123;<span class="number">8</span>&#123;data[<span class="number">5</span>]&#125;&#125;^data[<span class="number">23</span>:<span class="number">16</span>]+data[<span class="number">5</span>]&#125;;</span><br><span class="line">    <span class="keyword">assign</span> Z=&#123;data[<span class="number">31</span>],&#123;<span class="number">8</span>&#123;data[<span class="number">31</span>]&#125;&#125;^data[<span class="number">31</span>:<span class="number">24</span>]+data[<span class="number">31</span>]&#125;;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> flag[<span class="number">3</span>])<span class="keyword">begin</span></span><br><span class="line">       readyflag&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> LeftButton = data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> RightButton = data[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">assign</span> MidButton = data[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<h3 id="fpga验证-1">FPGA验证</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231029114649444.png" alt="image-20231029114649444" style="zoom:33%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231029114702434.png" alt="image-20231029114702434" style="zoom:33%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231029114712172.png" alt="image-20231029114712172" style="zoom:33%;" /></p>
<h3 id="错误现象及分析-1">错误现象及分析</h3>
<p>实验过程中并未出现错误。</p>
<h2 id="思考题">思考题</h2>
<blockquote>
<p>如何在键盘接收模块KeyBoardReceiver中考虑串行数据收到干扰导致传输出错的问题。</p>
</blockquote>
<p>发送端可以重复发送每个字符多次，接收端在接收到数据后进行比较，如果多次接收到相同的字符，则认为接收正确。</p>
<p>另外，在发送端在每个字符后增加一个校验位，接收端在接收到数据后计算校验位，如果校验位不匹配，则认为接收数据出错，丢弃该字符。</p>
<blockquote>
<p>什么是键盘的键位冲突？如何解决？</p>
</blockquote>
<p>键盘的键位冲突是指在同时按下多个键盘键时，键盘无法正确识别所按下的每个键，导致输入错误或无响应。键盘的硬件原理是通过一个扫描矩阵来检测按键的，而所谓的键位冲突是某些按键由于物理布局的关系会被判定为同时按下。</p>
<p>可以采用更换高级键盘的方式解决问题。一些高端键盘提供宏功能，可以将多个按键组合预设为一个宏，并通过单个按键触发。这样可以避免同时按下多个按键的问题。</p>
]]></content>
      <categories>
        <category>数电实验</category>
      </categories>
  </entry>
  <entry>
    <title>Lab4 乘除法器实验</title>
    <url>/2023/10/20/%E6%95%B0%E7%94%B5%E5%AE%9E%E9%AA%8C/Lab4%20%E4%B9%98%E9%99%A4%E6%B3%95%E5%99%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="乘除法器实验">乘除法器实验</h1>
<ul>
<li>221240083 陈正佺</li>
</ul>
<h2 id="补码一位乘法器">补码一位乘法器</h2>
<h3 id="实验整体方案设计">实验整体方案设计</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231020101120884.png" alt="image-20231020101120884" style="zoom:50%;" /></p>
<h3 id="子模块">子模块</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231020101221534.png" alt="image-20231020101221534" style="zoom:50%;" /></p>
<p>应调用ALU和选择器模块。</p>
<h3 id="仿真测试">仿真测试</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231020101848095.png" alt="image-20231020101848095" style="zoom:50%;" /></p>
<p>由仿真结果可知设计成功。</p>
<h3 id="错误现象及分析">错误现象及分析</h3>
<p>未出现错误。</p>
<h2 id="快速乘法器">快速乘法器</h2>
<h3 id="实验整体方案设计-1">实验整体方案设计</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231020102239659.png" alt="image-20231020102239659" style="zoom:30%;" /></p>
<p>依据8*8阵列乘法器的原理，类似的得出32*32阵列乘法器。</p>
<h3 id="子模块-1">子模块</h3>
<p>主要通过循环进位的方式得到结果。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">32</span>;i=i+<span class="number">1</span>)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j=j+<span class="number">1</span>)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">7&#x27;d32</span>)<span class="keyword">begin</span></span><br><span class="line">            b[j+i+<span class="number">1</span>]=(X[i]&amp;Y[j]&amp;a[j+i])|(X[i]&amp;Y[j]&amp;b[j+i])|(a[j+i]&amp;b[j+i]);</span><br><span class="line">            a[j+i]=(X[i]&amp;Y[j])^a[j+i]^b[j+i];<span class="keyword">end</span></span><br><span class="line">         <span class="keyword">if</span>(i==<span class="number">7&#x27;d32</span>)<span class="keyword">begin</span></span><br><span class="line">             b[j+i+<span class="number">1</span>]=(a[j+i]&amp;b[j+i]);</span><br><span class="line">             a[j+i]=a[j+i]^b[j+i];</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="仿真测试-1">仿真测试</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231020102855309.png" alt="image-20231020102855309" style="zoom:50%;" /></p>
<h3 id="错误现象及分析-1">错误现象及分析</h3>
<p>注意最后一行进位时用到的是已经更新后的进位。为了方便，我们将其视为33*32位的乘法，即在其中一个的前面补0，这样循环运行到最后一行的时候才不会出错。</p>
<h2 id="补码除法器">补码除法器</h2>
<h3 id="实验整体方案设计-2">实验整体方案设计</h3>
<p>被除数与除数同号做减法，异号做加法。接着判断余数符号是否改变，若改变则Q置1，否则置0。</p>
<p>重复上述操作直至循环结束。</p>
<p>最后分别判断除数和余数与被除数是否同号来进行商和余数的修正。</p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231020103838394.png" alt="image-20231020103838394" style="zoom:50%;" /></p>
<h3 id="子模块-2">子模块</h3>
<p>循环判断是否够减。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(start)<span class="keyword">begin</span></span><br><span class="line">            reg_r&lt;=<span class="number">32&#x27;b0</span>;</span><br><span class="line">            r_sign&lt;=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(dividend[<span class="number">31</span>]==<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                reg_q&lt;=~dividend+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> reg_q&lt;=dividend;</span><br><span class="line">            <span class="keyword">if</span>(divisor[<span class="number">31</span>]==<span class="number">1</span>)<span class="keyword">begin</span></span><br><span class="line">                reg_b&lt;=~divisor+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> reg_b&lt;=divisor;</span><br><span class="line">            count&lt;=<span class="number">0</span>;</span><br><span class="line">            busy&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(busy)<span class="keyword">begin</span></span><br><span class="line">            reg_r&lt;=sub_add[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line">            r_sign&lt;=sub_add[<span class="number">32</span>];</span><br><span class="line">            reg_q&lt;=&#123;reg_q[<span class="number">30</span>:<span class="number">0</span>],~sub_add[<span class="number">32</span>]&#125;;</span><br><span class="line">            count&lt;=count+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">31</span>)busy&lt;=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="错误现象及分析-2">错误现象及分析</h3>
<p>未出现错误。</p>
<h2 id="rv32m指令实现">RV32M指令实现</h2>
<h3 id="实验整体方案设计-3">实验整体方案设计</h3>
<p>实现以下功能，只需利用已有的乘除法器，其中有符号数与无符号数的运算结果为有符号数。</p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231020104310411.png" alt="image-20231020104310411" style="zoom:50%;" /></p>
<h3 id="子模块-3">子模块</h3>
<p>调用乘法器和除法器并用多路选择器来控制当前的功能。</p>
<p>为了可以在开发板上验证，创建父级模块使按键与开发板上的按键数量匹配。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="variable">.rs1</span>(&#123;<span class="number">8</span>&#123;x[<span class="number">3</span>:<span class="number">0</span>]&#125;&#125;),</span><br><span class="line"><span class="variable">.rs2</span>(&#123;<span class="number">8</span>&#123;y[<span class="number">3</span>:<span class="number">0</span>]&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>特别注意判in_error的情况，只要funct3$$4,且rs2为0，则会进行除0的操作，此时in_error为1。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(rs2==<span class="number">32&#x27;b0</span>&amp;&amp;funct3&gt;=<span class="number">3&#x27;d4</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	in_error=<span class="number">1</span>;out_valid=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="开发板验证">开发板验证</h3>
<p>考虑以下这组数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0x55555555</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a_1=<span class="number">0x55555555</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0xcccccccc</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b_1=<span class="number">0xcccccccc</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> c=(<span class="type">long</span> <span class="type">long</span>)a*(<span class="type">long</span> <span class="type">long</span>)b;c=c&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d=(<span class="type">long</span> <span class="type">long</span>)a*(<span class="type">long</span> <span class="type">long</span>)b_1;d=d&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> e=(<span class="type">long</span> <span class="type">long</span>)a_1*(<span class="type">long</span> <span class="type">long</span>)b_1;e=e&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n%x\n%x\n%x\n%x\n%x\n%x\n%x&quot;</span>,a*b,c,d,e,b/a,b_1/a_1,b%a,b_1%a_1);</span><br></pre></td></tr></table></figure>
<p>正确结果如下。</p>
<figure>
<img
src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231020105730117.png"
alt="image-20231020105730117" />
<figcaption aria-hidden="true">image-20231020105730117</figcaption>
</figure>
<p>开发板验证如下。</p>
<p><img src="C:\Users\86199\AppData\Local\Packages\Microsoft.YourPhone_8wekyb3d8bbwe\TempState\medias\扫描全能王 2023-10-20 11.00_8.jpg" alt="扫描全能王 2023-10-20 11.00_8" style="zoom:10%;" /><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231020110851897.png" alt="image-20231020110851897" style="zoom:10%;" /><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231020110910686.png" alt="image-20231020110910686" style="zoom:10%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231020110927743.png" alt="image-20231020110927743" style="zoom:10%;" /><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231020110939912.png" alt="image-20231020110939912" style="zoom:10%;" /><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231020110952874.png" alt="image-20231020110952874" style="zoom:10%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231020111010744.png" alt="image-20231020111010744" style="zoom:10%;" /><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231020111027457.png" alt="image-20231020111027457" style="zoom:10%;" /><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231020111041714.png" alt="image-20231020111041714" style="zoom:10%;" /></p>
<h3 id="错误现象及分析-3">错误现象及分析</h3>
<p>rst清空的时候要把寄存器中的东西都清空，否则in_valid和in_error可能并不会清零。</p>
<p>当有符号数与有符号数相乘时，第32位为符号位，而有符号数与无符号数相乘时，无符号数视为32位的非负数，要考虑可能出现的溢出问题。</p>
<h2 id="思考题">思考题</h2>
<ul>
<li><strong>分析rv32m模块的资源占用和性能特点。</strong></li>
</ul>
<blockquote>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231020122357483.png" alt="image-20231020122357483" style="zoom:50%;" /></p>
<p>乘法效率比除法效率要高。</p>
</blockquote>
<ul>
<li><strong>阐述浮点数的乘除法如何实现？</strong></li>
</ul>
<blockquote>
<p>乘法实现：</p>
<ol type="1">
<li>将两个浮点数的阶码相加，得到结果的阶码。</li>
<li>将两个浮点数的尾数相乘，得到结果的尾数。</li>
<li>根据尾数相乘的结果，进行规格化和舍入等处理操作，得到最终结果。</li>
</ol>
<p>除法实现：</p>
<ol type="1">
<li>将被除数的阶码减去除数的阶码，得到结果的阶码。</li>
<li>将被除数的尾数除以除数的尾数，得到结果的尾数。</li>
<li>根据尾数相除的结果，进行规格化和舍入等处理操作，得到最终结果。</li>
</ol>
</blockquote>
<ul>
<li><strong>分析当除数是一个常量时，如何通过乘以常量倒数的方法来得到近似的结果。与除法运算进
行对比分析，比如常量是3或者7时。 </strong></li>
</ul>
<blockquote>
<p>乘以常量的倒数的方法适用于那些除数为常量且在计算中频繁出现的情况。通过预先计算常量的倒数，并将乘法替换为乘以常量的倒数的运算，可以大大提高运算性能和效率。</p>
<p>对于常量为3的情况，我们可以选择使用其倒数1/3，即乘以0.3333作为近似的结果。这样，除法运算a/3就可以转化为乘法运算a*0.3333来进行计算。</p>
<p>对于常量为7的情况，我们可以选择使用其倒数1/7，即乘以0.1429作为近似的结果。这样，除法运算a/7就可以转化为乘法运算a*0.1429来进行计算。</p>
<p>对于性能方面的比较：</p>
<ul>
<li>乘以常量倒数的方法通常比除法运算更快，因为乘法运算的速度一般比除法运算快得多。</li>
<li>但是乘以常量倒数的方法需要多一次乘法运算和保留的小数位数，可能会导致精度的损失。</li>
</ul>
<p>对于精度方面的比较：</p>
<ul>
<li>乘以常量倒数的方法是一种近似计算方法，会引入一定的舍入误差。</li>
<li>除法运算通常可以得到更准确的结果，但需要更多的周期和硬件资源。</li>
</ul>
</blockquote>
<ul>
<li><strong>通过查找资料，阐述提高乘除法器的运算性能的思路和方法。</strong></li>
</ul>
<blockquote>
<p>要提高乘除法器的运算性能，可以考虑以下思路和方法：</p>
<ol type="1">
<li>优化算法：选择更高效的乘除算法可以显著提高运算性能。例如，可以使用快速傅立叶变换（FFT）来加速复数乘法，或者使用Booth算法来进行带符号乘法。</li>
<li>并行计算：利用乘除法器的并行性质，将计算任务分解为多个子任务，并同时进行计算。通过并行计算可以加速整个运算过程。可以采用数据并行、指令级并行或线程级并行等方式实现并行计算。</li>
<li>流水线技术：将乘除运算划分为多个阶段，并利用流水线技术使不同阶段的运算可同时进行。这样可以减小乘除操作的延迟，提高吞吐量。流水线技术需要合理划分阶段，解决流水线冲突和相关性问题。</li>
<li>基于硬件加速：通过在硬件电路中添加专门的计算单元和加速器，优化乘除运算的性能。例如，可以利用乘法累加器（MAC）单元、乘法累积器（MACC）单元、浮点运算单元等来提高运算效率。</li>
<li>采用预计算和查表方式：对于一些常见的乘除操作或特定的数值范围，可以事先进行预计算或者将结果存入查找表中。在实际运算时，直接查表或者使用预计算结果，避免重复运算，从而加速乘除运算。</li>
<li>优化电路结构：通过改进电路结构，减小运算单元的延迟和功耗。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数电实验</category>
      </categories>
  </entry>
  <entry>
    <title>Lab3 算术逻辑部件实验</title>
    <url>/2023/10/12/%E6%95%B0%E7%94%B5%E5%AE%9E%E9%AA%8C/Lab3%20%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E9%83%A8%E4%BB%B6%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="算术逻辑部件实验">算术逻辑部件实验</h1>
<h2 id="带标志位的加减运算部件">带标志位的加减运算部件</h2>
<h3 id="实验整体方案设计">实验整体方案设计</h3>
<p>利用给出的16位先行进位加法器级联实现32位加减法器。</p>
<h3 id="子模块原理说明">子模块原理说明</h3>
<p>由两个16位加法器级联。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>]Pi,Gi;</span><br><span class="line"><span class="keyword">wire</span>[<span class="number">1</span>:<span class="number">0</span>]c;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>]d;</span><br><span class="line"><span class="keyword">assign</span> c[<span class="number">0</span>]=sub;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] y1=sub?~y:y;</span><br><span class="line">CLA_16 f1(f[<span class="number">15</span>:<span class="number">0</span>],d[<span class="number">0</span>],x[<span class="number">15</span>:<span class="number">0</span>],y1[<span class="number">15</span>:<span class="number">0</span>],c[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">assign</span> c[<span class="number">1</span>]=d[<span class="number">0</span>];</span><br><span class="line">CLA_16 f2(f[<span class="number">31</span>:<span class="number">16</span>],d[<span class="number">1</span>],x[<span class="number">31</span>:<span class="number">16</span>],y1[<span class="number">31</span>:<span class="number">16</span>],c[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">assign</span> cout=d[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">assign</span> CF=sub+cout;</span><br><span class="line"><span class="keyword">assign</span> SF=f[<span class="number">31</span>];</span><br><span class="line"><span class="keyword">assign</span> ZF=(f==<span class="number">0</span>)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span> OF=(~x[<span class="number">31</span>]&amp;~y1[<span class="number">31</span>]&amp;f[<span class="number">31</span>])|(x[<span class="number">31</span>]&amp;y1[<span class="number">31</span>]&amp;~f[<span class="number">31</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="仿真测试">仿真测试</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231012133737900.png" alt="image-20231012133737900" style="zoom: 33%;" /></p>
<p>可知电路满足设计需求。</p>
<h3 id="错误现象及分析">错误现象及分析</h3>
<p>注意OF用的y是取反之后的而不是原先的。</p>
<h2 id="桶形移位器">桶形移位器</h2>
<h3 id="实验整体方案设计-1">实验整体方案设计</h3>
<p>仿照8位桶形移位器给出32位桶形移位器。</p>
<h3 id="子模块原理说明-1">子模块原理说明</h3>
<p>将多路选择器的级联扩展到5级，数据位扩展到32位。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(*)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span>(AL)</span><br><span class="line"><span class="number">1&#x27;b1</span>:<span class="comment">//算术</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(LR)<span class="comment">//左移</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">dout = shamt[<span class="number">0</span>] ? &#123;din[<span class="number">30</span>:<span class="number">0</span>], <span class="number">1&#x27;b0</span>&#125; : din;</span><br><span class="line">dout = shamt[<span class="number">1</span>] ? &#123;dout[<span class="number">29</span>:<span class="number">0</span>], <span class="number">2&#x27;b0</span>&#125; : dout;</span><br><span class="line">dout = shamt[<span class="number">2</span>] ? &#123;dout[<span class="number">27</span>:<span class="number">0</span>], <span class="number">4&#x27;b0</span>&#125; : dout;</span><br><span class="line">dout = shamt[<span class="number">3</span>] ? &#123;dout[<span class="number">23</span>:<span class="number">0</span>], <span class="number">8&#x27;b0</span>&#125; : dout;</span><br><span class="line">dout = shamt[<span class="number">4</span>] ? &#123;dout[<span class="number">15</span>:<span class="number">0</span>], <span class="number">16&#x27;b0</span>&#125; : dout;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span><span class="comment">//右移</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">dout = shamt[<span class="number">0</span>] ? &#123;din[<span class="number">31</span>], din[<span class="number">31</span>:<span class="number">1</span>]&#125; : din;</span><br><span class="line">dout = shamt[<span class="number">1</span>] ? &#123;&#123;<span class="number">2</span>&#123;dout[<span class="number">31</span>]&#125;&#125;, dout[<span class="number">31</span>:<span class="number">2</span>]&#125; : dout;</span><br><span class="line">dout = shamt[<span class="number">2</span>] ? &#123;&#123;<span class="number">4</span>&#123;dout[<span class="number">31</span>]&#125;&#125;, dout[<span class="number">31</span>:<span class="number">4</span>]&#125; : dout;</span><br><span class="line">dout = shamt[<span class="number">3</span>] ? &#123;&#123;<span class="number">8</span>&#123;dout[<span class="number">31</span>]&#125;&#125;, dout[<span class="number">31</span>:<span class="number">8</span>]&#125; : dout;</span><br><span class="line">dout = shamt[<span class="number">4</span>] ? &#123;&#123;<span class="number">16</span>&#123;dout[<span class="number">31</span>]&#125;&#125;, dout[<span class="number">31</span>:<span class="number">16</span>]&#125; : dout;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="number">1&#x27;b0</span>:<span class="comment">//逻辑</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(LR)<span class="comment">//左移</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">dout = shamt[<span class="number">0</span>] ? &#123;din[<span class="number">30</span>:<span class="number">0</span>], <span class="number">1&#x27;b0</span>&#125; : din;</span><br><span class="line">dout = shamt[<span class="number">1</span>] ? &#123;dout[<span class="number">29</span>:<span class="number">0</span>], <span class="number">2&#x27;b0</span>&#125; : dout;</span><br><span class="line">dout = shamt[<span class="number">2</span>] ? &#123;dout[<span class="number">27</span>:<span class="number">0</span>], <span class="number">4&#x27;b0</span>&#125; : dout;</span><br><span class="line">dout = shamt[<span class="number">3</span>] ? &#123;dout[<span class="number">23</span>:<span class="number">0</span>], <span class="number">8&#x27;b0</span>&#125; : dout;</span><br><span class="line">dout = shamt[<span class="number">4</span>] ? &#123;dout[<span class="number">15</span>:<span class="number">0</span>], <span class="number">16&#x27;b0</span>&#125; : dout;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span><span class="comment">//右移</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">dout = shamt[<span class="number">0</span>] ? &#123;<span class="number">1&#x27;b0</span>, din[<span class="number">31</span>:<span class="number">1</span>]&#125; : din;</span><br><span class="line">dout = shamt[<span class="number">1</span>] ? &#123;<span class="number">2&#x27;b0</span>, dout[<span class="number">31</span>:<span class="number">2</span>]&#125; : dout;</span><br><span class="line">dout = shamt[<span class="number">2</span>] ? &#123;<span class="number">4&#x27;b0</span>, dout[<span class="number">31</span>:<span class="number">4</span>]&#125; : dout;</span><br><span class="line">dout = shamt[<span class="number">3</span>] ? &#123;<span class="number">8&#x27;b0</span>, dout[<span class="number">31</span>:<span class="number">8</span>]&#125; : dout;</span><br><span class="line">dout = shamt[<span class="number">4</span>] ? &#123;<span class="number">16&#x27;b0</span>, dout[<span class="number">31</span>:<span class="number">16</span>]&#125; : dout;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="仿真测试-1">仿真测试</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231012134206141.png" alt="image-20231012134206141" style="zoom:33%;" /></p>
<p>可知电路满足设计需求。</p>
<h3 id="错误现象及分析-1">错误现象及分析</h3>
<p>并未遇到错误。</p>
<h2 id="位alu">32位ALU</h2>
<h3 id="实验整体方案设计-2">实验整体方案设计</h3>
<p>通过4位控制信号ALUctr生成具体控制信号来进行各种运算。</p>
<p>加减比较用上面的加法器实现，移位用上面的桶形移位器实现。与或非直接连接到多路选择器实现。</p>
<h3 id="子模块原理说明-2">子模块原理说明</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231012134518767.png" alt="image-20231012134518767" style="zoom:50%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231012143039602.png" alt="image-20231012143039602" style="zoom:50%;" /></p>
<p>并写出顶层模块以在实验板进行验证。</p>
<h3 id="仿真测试-2">仿真测试</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231012134758338.png" alt="image-20231012134758338" style="zoom:33%;" /></p>
<p>可知电路满足设计需求。</p>
<h3 id="fpga验证">FPGA验证</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231012142459136.png" alt="image-20231012142459136" style="zoom:10%;" /><img src="C:\Users\86199\AppData\Local\Packages\Microsoft.YourPhone_8wekyb3d8bbwe\TempState\medias\QCOK_NEXYSM_7.jpg" alt="QCOK_NEXYSM_7" style="zoom:10%;" /><img src="C:\Users\86199\AppData\Local\Packages\Microsoft.YourPhone_8wekyb3d8bbwe\TempState\medias\QCOK_NEXYSM_6.jpg" alt="QCOK_NEXYSM_6" style="zoom:10%;"/><img src="C:\Users\86199\AppData\Local\Packages\Microsoft.YourPhone_8wekyb3d8bbwe\TempState\medias\QCOK_NEXYSM_5.jpg" alt="QCOK_NEXYSM_5" style="zoom:10%;" /><img src="C:\Users\86199\AppData\Local\Packages\Microsoft.YourPhone_8wekyb3d8bbwe\TempState\medias\QCOK_NEXYSM_4.jpg" alt="QCOK_NEXYSM_4" style="zoom:10%;" /><img src="C:\Users\86199\AppData\Local\Packages\Microsoft.YourPhone_8wekyb3d8bbwe\TempState\medias\QCOK_NEXYSM_3.jpg" alt="QCOK_NEXYSM_3" style="zoom:10%;" /><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231012142818158.png" alt="image-20231012142818158" style="zoom:10%;" /><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231012142841151.png" alt="image-20231012142841151" style="zoom:10%;" /></p>
<h3 id="错误现象及分析-2">错误现象及分析</h3>
<p>选择移位时，datab输入0001，但实际上由于重复8次输入，读入的B为10001，移了17位而不是1位。</p>
<h2 id="思考题">思考题</h2>
<ol type="1">
<li><p><strong>分析32位ALU的资源占用情况。</strong></p>
<p>有异或门阵列，与门阵列，或门阵列，异或门阵列，桶形移位器，8-多路选择器，2-多路选择器，两个异或门。</p></li>
<li><p><strong>比较运算直接使用组合电路比较器来实现，则 32 位 ALU
电路原理图需要做哪些修改？</strong></p>
<p>A,B直接送入比较器进行比较，并通过多路选择器得到result，而不通过减法器的符号进行判断。</p></li>
<li><p><strong>在 32 位 ALU 的基础上如何实现 64 位的 ALU？</strong></p>
<p>加减：同上16位加法器级联32位加减法器，这里32位ALU中的加法功能级联实现64位加减法器。</p>
<p>比较：我们已经实现了64位加减法器，利用符号位判断比较（也可以直接将比较器级联，即先比较高32位，相同的话再看低32位）。</p>
<p>与或非：每位都是独立的，所以两部分结果直接合并起来即可。</p>
<p>移位：32位移位器级联实现64为桶形移位器，注意右移的时候高32位移出的补到低32位前面。</p></li>
<li><p><strong>查找资料说明还有哪些并行加法器的设计方法，并详细介绍其中一种方法。</strong></p>
<p>除了行波进位，还有跳跃进位，选择进位，超前进位。</p>
<p>我们介绍选择<strong>进位加法器</strong>。</p>
<p>根据进位计算公式</p>
<figure>
<img
src="https://bkimg.cdn.bcebos.com/formula/af1632ea0305a3049b238642008a7082.svg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>，可以知道进位信号的得出需要依赖前级的进位信号，如果不考虑前级进位Ci的值，而同时计算出当Ci=0和Ci=1时向第i+1位的进位值，则所有位的进位与结果可以同时计算，等真正的进位信号产生之后，再利用它选择出正确的结果，这种加法器就是选择进位加法器。它是通过提高计算的并行性来改进加法器的速度的。在实际的选择进位加法器中，为了减少等待时间，总是将n位分成K段，其中第k个段中有nk位。划分后的每个段内安排两个加法器，同时计算向这一段的最末位的进位Cnk是0和1两种情况下的和，这样各段的计算是并行的。</p>
<p>一般来说，对基本的选择进位加法器进行合理的分段可以有效地降低延迟。例如，在最低两位(第0和第1位)采用基本的行波进位加法器，第2位和第3位再使用进位选择加法器。</p></li>
</ol>
]]></content>
      <categories>
        <category>数电实验</category>
      </categories>
  </entry>
  <entry>
    <title>Lab6 VGA接口实验</title>
    <url>/2023/11/09/%E6%95%B0%E7%94%B5%E5%AE%9E%E9%AA%8C/Lab6%20VGA%E6%8E%A5%E5%8F%A3%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="vga接口实验">VGA接口实验</h1>
<blockquote>
<ul>
<li>221240083 陈正佺</li>
</ul>
</blockquote>
<h3 id="实验整体方案设计">实验整体方案设计</h3>
<ol type="1">
<li><strong>VGACtrl 模块：</strong>
<ul>
<li><strong>功能：</strong> VGACtrl
模块是图形显示系统的控制模块，负责按时钟信号对屏幕进行逐行扫描。</li>
<li><strong>工作原理：</strong>
模块通过时钟信号同步地扫描整个屏幕，从上到下，逐行获取像素的坐标 (x,
y)。这些坐标信息将用于后续的图形绘制。</li>
</ul></li>
<li><strong>VGADraw 模块：</strong>
<ul>
<li><strong>功能：</strong> VGADraw
模块是图形显示系统的绘制模块，负责根据给定的坐标 (x, y)
提供像素的颜色。</li>
<li><strong>工作原理：</strong> 模块接收来自 VGACtrl
模块的坐标信息，然后根据预定的规则或算法，为每个像素确定相应的颜色。颜色通常以
12 位二进制数表示，其中可能包括红、绿、蓝等颜色分量。</li>
</ul></li>
<li><strong>KeyboardSim 模块：</strong>
<ul>
<li><strong>功能：</strong> KeyboardSim
模块是键盘模拟器模块，接收键盘信号并将其应用到 VGADraw 模块上。</li>
<li><strong>工作原理：</strong>
该模块负责模拟键盘输入，可能接收按键的状态、按键码等信息。根据接收到的键盘输入，可能触发
VGADraw
模块的相应操作，例如在屏幕上绘制图形、改变颜色或执行其他与键盘输入相关的图形操作。</li>
</ul></li>
</ol>
<h3 id="子模块设计">子模块设计</h3>
<p>KeyboardSim在lab5中已经给过了，VGACtrl实验中也有，我们真正要设计的是VGADraw。</p>
<p>我们需要在VGADraw中实现题中要求的4种状态的绘制：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(*)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(state==<span class="number">2&#x27;b00</span>)<span class="keyword">begin</span></span><br><span class="line">pix_data=(asciiout[<span class="number">127</span> - ((pix_y%<span class="number">16</span>)*<span class="number">8</span>) - ((pix_x)%<span class="number">8</span>)] == <span class="number">1&#x27;b1</span>&amp;&amp;pix_valid)?<span class="number">12&#x27;b111111111111</span>: <span class="number">12&#x27;b0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span>(state==<span class="number">2&#x27;b01</span>)<span class="keyword">begin</span></span><br><span class="line">pix_data=&#123;temp_r[<span class="number">7</span>:<span class="number">4</span>], temp_g[<span class="number">7</span>:<span class="number">4</span>],temp_b[<span class="number">7</span>:<span class="number">4</span>]&#125;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span>(state==<span class="number">2&#x27;b10</span>)<span class="keyword">begin</span></span><br><span class="line">pix_data=(pix_valid)?staticpix:<span class="number">12&#x27;d0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span>(state==<span class="number">2&#x27;b11</span>)<span class="keyword">begin</span></span><br><span class="line">pix_data=(asciiout[<span class="number">127</span> - ((pix_y%<span class="number">16</span>)*<span class="number">8</span>) - ((pix_x)%<span class="number">8</span>)] == <span class="number">1&#x27;b1</span>&amp;&amp;pix_valid)?<span class="number">12&#x27;b111111111111</span>: <span class="number">12&#x27;b0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>接下来在主模块xterm中实现状态的切换。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(screen[cursor_y][<span class="number">2</span>] == <span class="number">8&#x27;h47</span>)<span class="keyword">begin</span> state &lt;= <span class="number">2&#x27;b01</span>;<span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(screen[cursor_y][<span class="number">2</span>] == <span class="number">8&#x27;h49</span>)<span class="keyword">begin</span> state &lt;= <span class="number">2&#x27;b10</span>;<span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(screen[cursor_y][<span class="number">2</span>] == <span class="number">8&#x27;h43</span>)<span class="keyword">begin</span></span><br><span class="line">	cursor_y &lt;= cursor_y + <span class="number">1</span>;</span><br><span class="line">	screen[cursor_y + <span class="number">1</span>][<span class="number">1</span>] &lt;= <span class="number">8&#x27;h43</span>;screen[cursor_y + <span class="number">1</span>][<span class="number">2</span>] &lt;= <span class="number">8&#x27;h61</span>;</span><br><span class="line">    screen[cursor_y + <span class="number">1</span>][<span class="number">3</span>] &lt;= <span class="number">8&#x27;h6c</span>;screen[cursor_y + <span class="number">1</span>][<span class="number">4</span>] &lt;= <span class="number">8&#x27;h63</span>;screen[cursor_y + <span class="number">1</span>][<span class="number">5</span>] &lt;= <span class="number">8&#x27;h75</span>;</span><br><span class="line">	screen[cursor_y + <span class="number">1</span>][<span class="number">6</span>] &lt;= <span class="number">8&#x27;h6c</span>;screen[cursor_y + <span class="number">1</span>][<span class="number">7</span>] &lt;= <span class="number">8&#x27;h61</span>;</span><br><span class="line">    screen[cursor_y + <span class="number">1</span>][<span class="number">8</span>] &lt;= <span class="number">8&#x27;h74</span>;screen[cursor_y + <span class="number">1</span>][<span class="number">9</span>] &lt;= <span class="number">8&#x27;h6f</span>;screen[cursor_y + <span class="number">1</span>][<span class="number">10</span>] &lt;= <span class="number">8&#x27;h72</span>;</span><br><span class="line">    screen[cursor_y + <span class="number">1</span>][<span class="number">11</span>] &lt;= <span class="number">8&#x27;h3e</span>;screen[cursor_y + <span class="number">1</span>][<span class="number">12</span>] &lt;= <span class="number">8&#x27;h5f</span>;</span><br><span class="line">    cursor_x &lt;= <span class="number">12</span>;line &lt;= <span class="number">0</span>;screen[cursor_y][cursor_x] &lt;= <span class="number">0</span>;</span><br><span class="line">	state &lt;= <span class="number">2&#x27;b11</span>;<span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这样遇到我们要求的特殊字母输入，就会跳转到相应的图片或文本。</p>
<p>接下来还缺少一个复位的模块。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(BTNC == <span class="number">1</span>)<span class="keyword">begin</span></span><br><span class="line">            cursor_x &lt;= <span class="number">2</span>;</span><br><span class="line">            cursor_y &lt;= <span class="number">2</span>;</span><br><span class="line">            line &lt;= <span class="number">0</span>;</span><br><span class="line">            reset &lt;= <span class="number">1</span>;</span><br><span class="line">            state &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这样，按下BTNC即可恢复最初的终端画面。</p>
<h3 id="fpga验证">FPGA验证</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231111193454478.png" alt="image-20231111193454478" style="zoom:20%;" /></p>
<ul>
<li>显示终端界面。</li>
</ul>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231111193545824.png" alt="image-20231111193545824" style="zoom:20%;" /></p>
<ul>
<li>显示文本。</li>
</ul>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231111193602125.png" alt="image-20231111193602125" style="zoom:25%;" /></p>
<ul>
<li>显示彩色图形。</li>
</ul>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231111193614896.png" alt="image-20231111193614896" style="zoom:25%;" /></p>
<ul>
<li>显示图片。</li>
</ul>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231111193626271.png" alt="image-20231111193626271" style="zoom:20%;" /></p>
<ul>
<li>键盘输入进行写入和换行、退格。</li>
</ul>
<h3 id="错误现象及分析">错误现象及分析</h3>
<p>在写状态机的时候出现了timing
loop，是因为状态循环的过程中将输出状态接入了输入状态。于是考虑一个单向的状态链接：从终端界面可以分别跳转到图形、图片、文本页面，但我们需要借助BTNC按钮进行复位，这样就解决了timing
loop的问题。确保状态机在状态迁移中不形成循环依赖非常重要，这避免了出现timing
loop，同时保证了系统的正常运行。</p>
<p>我需要在状态机的设计中确保状态之间的转移是单向的，并且有一个明确定义的初始状态，以及一个可以将系统状态重置到初始状态的机制。使用按钮BTNC进行复位是一个很好的解决方案。这样的状态机：</p>
<ul>
<li><strong>State A - Terminal Interface:</strong> 从终端界面开始</li>
<li><strong>State B - Graphical Interface:</strong> 跳转到图形页面</li>
<li><strong>State C - Image Interface:</strong> 跳转到图片页面</li>
<li><strong>State D - Text Interface:</strong> 跳转到文本页面</li>
</ul>
<p>此外，按钮BTNC被按下，来将系统状态重置到初始状态（State
A），这样可以避免任何潜在的timing loop问题。</p>
<p>确保状态机逻辑清晰，状态之间的转移是按照预期的方向进行的，避免状态之间的相互依赖，这样可以确保系统的稳定。</p>
<h3 id="思考题">思考题</h3>
<blockquote>
<p>如何在显示器分辨率设置为1280×1024时，在屏幕中间显示640×480的图像？</p>
</blockquote>
<p>只是有效区域变成了屏幕中间的那部分区域。重新刻画x,y的坐标，使其位于中间的区域才有效，即可读入640*480的图像。</p>
<ol type="1">
<li><strong>计算居中位置：</strong>
首先，计算图像在屏幕上的居中位置。对于分辨率为1280×1024的屏幕，居中位置的起始点可以通过以下计算得到：
<ul>
<li>居中横坐标起始点：(1280 - 640) / 2 = 320</li>
<li>居中纵坐标起始点：(1024 - 480) / 2 = 272</li>
</ul></li>
<li><strong>设置图像显示：</strong>
在屏幕上绘制或显示640×480的图像，并将其位置设置为计算得到的居中位置。</li>
</ol>
<blockquote>
<p>试试实现在屏幕上彩色字符（如图6.15所示）或实现类似电影Matrix开头的字符雨效果。</p>
</blockquote>
<p>我们在实现普通的白色字符时，每个字块的颜色为0xfff。现在要实现彩色字符，只需要更改颜色属性即可。我们可以让颜色随着坐标而变化，这样即可得到有颜色的字符。实现字符雨的话，我参考了计算机系统基础的PA2中的打字小游戏，主要用来实现字符的下落。</p>
<ol type="1">
<li><p><strong>字符显示原理：</strong></p>
<ul>
<li><p>对于彩色字符显示，每个字符分配一个特定的颜色，使用RGB格式来表示颜色，即每个像素有红、绿、蓝三个分量。</p></li>
<li><p>控制每个字符的颜色和显示位置，可以在屏幕上显示彩色字符。</p></li>
</ul></li>
<li><p><strong>显示控制原理：</strong></p>
<ul>
<li>时序控制负责生成正确的显示时钟和同步信号，以确保图像能够正确显示在屏幕上。</li>
<li>渲染阶段会根据输入的图像信息和控制信号生成最终的像素数据。输出阶段负责将像素数据发送到屏幕进行显示。</li>
</ul></li>
<li><p><strong>字符雨效果原理：</strong></p>
<ul>
<li>类似电影《Matrix》开头的字符雨效果通常涉及文本字符的逐行下落，以及在下落过程中改变字符颜色和速度。</li>
<li>需要一个字符产生模块来生成随机的字符，并在屏幕上以适当的速率垂直移动这些字符。</li>
<li>同时，需要控制字符的颜色和速度，以达到期望的视觉效果。</li>
</ul></li>
<li><p><strong>颜色控制原理：</strong></p>
<ul>
<li>通过动态调整每个像素的RGB值，可以控制像素的颜色。进而可以实现字符的彩色显示和字符雨效果中字符颜色的变化。</li>
</ul></li>
</ol>
<blockquote>
<p>说说如何字屏幕上显示汉字（实验资源中HZK16S汉字16×16点阵字库文件）？</p>
</blockquote>
<p>实现字符需要8*16的像素块，实现汉字也是同理，只不过是换成了16*16的字块。对于每个字都是在16*16的范围内让一些像素呈白色，一些呈黑色。类似字库文件进行读入即可。</p>
<p>这样就做到了在屏幕上显示字库文件，但并不能与键盘进行交互(可能需要输入法的支持什么的)。</p>
]]></content>
      <categories>
        <category>数电实验</category>
      </categories>
  </entry>
  <entry>
    <title>Lab7 存储器体系实验</title>
    <url>/2023/11/15/%E6%95%B0%E7%94%B5%E5%AE%9E%E9%AA%8C/Lab7%20%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<hr />
<h1 id="存储器体系实验">存储器体系实验</h1>
<ul>
<li><code>221240083 陈正佺 匡亚明学院</code></li>
</ul>
<h3 id="实验整体方案设计">实验整体方案设计</h3>
<p>我们要利用4片8位64KB的RAM级联成一个32位256KB的存储器。由4个8位存储器构成32位的存储器，4个8位分别为32位的4个字节。因此只需在读取时控制相应的片选信号即可。</p>
<p>通过Memop可以控制读取或存取的是1,2,4字节，
但控制不了到底是第几个字节，因此需要使用地址的低两位来判断到底存取的是那个字节位。</p>
<p>这样就利用8位级联构成了32位。接下来要考虑的是复位清零的问题。我们会在子模块设计里面详细介绍。</p>
<p>最后要实现顶层模块，将读出的32位数据展示在FPGA板上，这个我们已经实现多次，这里类似实现即可。</p>
<h3 id="子模块设计">子模块设计</h3>
<blockquote>
<p><code>32位mem模块</code></p>
</blockquote>
<p>对8位的mem模块调用4次。但是与讲义里给的不同，这里添加了低两位的地址，实现了任意字节的读取和存放。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> (&#123;MemOp,addr[<span class="number">1</span>:<span class="number">0</span>]&#125;)</span><br><span class="line"> <span class="number">5&#x27;b01000</span>: <span class="keyword">begin</span> dataout = outtmp; <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"> <span class="number">5&#x27;b10000</span>: <span class="keyword">begin</span> dataout = &#123;<span class="number">24&#x27;h000000</span>, outtmp[<span class="number">7</span>:<span class="number">0</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"> <span class="number">5&#x27;b10001</span>: <span class="keyword">begin</span> dataout = &#123;<span class="number">24&#x27;h000000</span>, outtmp[<span class="number">15</span>:<span class="number">8</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"> <span class="number">5&#x27;b10010</span>: <span class="keyword">begin</span> dataout = &#123;<span class="number">24&#x27;h000000</span>, outtmp[<span class="number">23</span>:<span class="number">16</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"> <span class="number">5&#x27;b10011</span>: <span class="keyword">begin</span> dataout = &#123;<span class="number">24&#x27;h000000</span>, outtmp[<span class="number">31</span>:<span class="number">24</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"> <span class="number">5&#x27;b10100</span>: <span class="keyword">begin</span> dataout = &#123;<span class="number">16&#x27;h0000</span>, outtmp[<span class="number">15</span>:<span class="number">0</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"> <span class="number">5&#x27;b10110</span>: <span class="keyword">begin</span> dataout = &#123;<span class="number">16&#x27;h0000</span>, outtmp[<span class="number">31</span>:<span class="number">16</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"> <span class="number">5&#x27;b00000</span>: <span class="keyword">begin</span> dataout = &#123;&#123;<span class="number">24</span>&#123;outtmp[<span class="number">7</span>]&#125;&#125;, outtmp[<span class="number">7</span>:<span class="number">0</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"> <span class="number">5&#x27;b00001</span>: <span class="keyword">begin</span> dataout = &#123;&#123;<span class="number">24</span>&#123;outtmp[<span class="number">15</span>]&#125;&#125;, outtmp[<span class="number">15</span>:<span class="number">8</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"> <span class="number">5&#x27;b00010</span>: <span class="keyword">begin</span> dataout = &#123;&#123;<span class="number">24</span>&#123;outtmp[<span class="number">23</span>]&#125;&#125;, outtmp[<span class="number">23</span>:<span class="number">16</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"> <span class="number">5&#x27;b00011</span>: <span class="keyword">begin</span> dataout = &#123;&#123;<span class="number">24</span>&#123;outtmp[<span class="number">31</span>]&#125;&#125;, outtmp[<span class="number">31</span>:<span class="number">24</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"> <span class="number">5&#x27;b00100</span>: <span class="keyword">begin</span> dataout = &#123;&#123;<span class="number">16</span>&#123;outtmp[<span class="number">15</span>]&#125;&#125;, outtmp[<span class="number">15</span>:<span class="number">0</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"> <span class="number">5&#x27;b00110</span>: <span class="keyword">begin</span> dataout = &#123;&#123;<span class="number">16</span>&#123;outtmp[<span class="number">31</span>]&#125;&#125;, outtmp[<span class="number">31</span>:<span class="number">16</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">default</span>:dataout = outtmp;</span><br><span class="line"> <span class="keyword">endcase</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">begin</span> </span><br><span class="line"> <span class="keyword">case</span> (&#123;MemOp,addr[<span class="number">1</span>:<span class="number">0</span>]&#125;)</span><br><span class="line"> <span class="number">5&#x27;b01000</span>: <span class="keyword">begin</span> intmp = datain; <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"> <span class="number">5&#x27;b00000</span>: <span class="keyword">begin</span> intmp = &#123;outtmp[<span class="number">31</span>:<span class="number">8</span>], datain[<span class="number">7</span>:<span class="number">0</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"> <span class="number">5&#x27;b00001</span>: <span class="keyword">begin</span> intmp = &#123;outtmp[<span class="number">31</span>:<span class="number">16</span>], datain[<span class="number">15</span>:<span class="number">8</span>],outtmp[<span class="number">7</span>:<span class="number">0</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"> <span class="number">5&#x27;b00010</span>: <span class="keyword">begin</span> intmp = &#123;outtmp[<span class="number">31</span>:<span class="number">24</span>], datain[<span class="number">23</span>:<span class="number">16</span>],outtmp[<span class="number">15</span>:<span class="number">0</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"> <span class="number">5&#x27;b00011</span>: <span class="keyword">begin</span> intmp = &#123;datain[<span class="number">31</span>:<span class="number">24</span>],outtmp[<span class="number">23</span>:<span class="number">0</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"> <span class="number">5&#x27;b00100</span>: <span class="keyword">begin</span> intmp = &#123;outtmp[<span class="number">31</span>:<span class="number">16</span>], datain[<span class="number">15</span>:<span class="number">0</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"> <span class="number">5&#x27;b00110</span>: <span class="keyword">begin</span> intmp = &#123;datain[<span class="number">15</span>:<span class="number">0</span>],outtmp[<span class="number">31</span>:<span class="number">16</span>]&#125;; <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">default</span>:intmp = datain;</span><br><span class="line"> <span class="keyword">endcase</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>复位清零模块</code></p>
</blockquote>
<p>设计1个16倒计时，每毫秒清除1个存储器，就可以在16ms的时间内实现复位清零。一旦按下<code>BTNC</code>,就会开始清零，直到计数器变为0，此时进入允许写入的状态。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] countdown;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> msclk <span class="keyword">or</span> <span class="keyword">posedge</span> BTNC)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(BTNC)<span class="keyword">begin</span></span><br><span class="line">        countdown &lt;= <span class="number">16&#x27;d16</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(countdown != <span class="number">0</span>)<span class="keyword">begin</span></span><br><span class="line">        countdown &lt;= countdown - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] true_addr = &#123;<span class="number">12&#x27;b0</span>, addr_L4b&#125;;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] true_datain = &#123;datain_L8b, datain_L8b, datain_L8b, datain_L8b&#125;;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] final_addr = (countdown == <span class="number">0</span>) ? true_addr : countdown-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] final_datain = (countdown == <span class="number">0</span>) ? true_datain : <span class="number">32&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">wire</span> final_we = (countdown == <span class="number">0</span>) ? we : <span class="number">1&#x27;b1</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>顶层模块</code></p>
</blockquote>
<p>利用分频器和七段码进行显示。</p>
<h3 id="fpga验证">FPGA验证</h3>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231117164004104.png" alt="image-20231117164004104" style="zoom:42%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231117164021897.png" alt="image-20231117164021897" style="zoom:46%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231117164035046.png" alt="image-20231117164035046" style="zoom:50%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231117164109107.png" alt="image-20231117164109107" style="zoom:46%;" /></p>
<h3 id="错误现象及分析">错误现象及分析</h3>
<p>通过Memop可以控制读取或存取的是1,2,4字节，
但控制不了到底是第几个字节，因此需要使用地址的低两位来判断到底存取的是那个字节位。</p>
<p>Memop和地址的低两位结合起来确定具体的存取字节。这样的设计可以有效地对齐存储，确保按照地址的低两位进行存取时，只能存取到相应的字节位置。这也符合计算机体系结构中的字节对齐原则。由于按地址对齐进行存储，因此存取两位字节时，只能存取在12位或者34位，不会出现存取在23位的情况。</p>
<h3 id="思考题">思考题</h3>
<blockquote>
<p>分别采用分布式<code>RAM</code>和块<code>RAM</code>实现存储器，通过仿真程序分析异步读和同步读的时序状态。</p>
</blockquote>
<ul>
<li>分布式RAM：</li>
</ul>
<ol type="1">
<li><strong>异步读时序状态分析：</strong>
<ul>
<li>发起读请求：输入读地址并激活读使能信号。</li>
<li>地址解码：将读地址解码为多个子模块的地址。</li>
<li>数据获取：各个子模块独立地获取数据。</li>
<li>数据汇总：将从各个子模块获取的数据进行汇总。</li>
<li>输出数据：输出给用户。</li>
</ul></li>
<li><strong>同步读时序状态分析：</strong>
<ul>
<li>发起读请求：输入读地址并激活读使能信号。</li>
<li>地址解码：将读地址解码为多个子模块的地址。</li>
<li>数据获取：各个子模块同时获取数据。</li>
<li>数据汇总：将同时获取的数据进行汇总。</li>
<li>输出数据：输出给用户。</li>
</ul></li>
</ol>
<ul>
<li>块RAM：</li>
</ul>
<ol type="1">
<li><strong>异步读时序状态分析：</strong>
<ul>
<li>发起读请求：输入读地址并激活读使能信号。</li>
<li>地址解码：将读地址解码为块RAM中的特定块。</li>
<li>数据获取：块RAM读取整个块中的数据。</li>
<li>输出数据：输出给用户。</li>
</ul></li>
<li><strong>同步读时序状态分析：</strong>
<ul>
<li>发起读请求：输入读地址并激活读使能信号。</li>
<li>地址解码：将读地址解码为块RAM中的特定块。</li>
<li>数据获取：块RAM同时获取整个块中的数据。</li>
<li>输出数据：输出给用户。</li>
</ul></li>
</ol>
<ul>
<li><p>异步读和同步读的比较：</p></li>
<li><p><strong>异步读：</strong></p>
<ul>
<li>优点：更简单，对于一些低速应用可能更适用。</li>
<li>缺点：时序可能不太容易控制，因为各个子模块独立地响应请求。</li>
</ul></li>
<li><p><strong>同步读：</strong></p>
<ul>
<li>优点：时序更容易控制，适用于高速应用。</li>
<li>缺点：设计和实现可能相对复杂。</li>
</ul></li>
</ul>
<blockquote>
<p>分析<code>Cache</code>大小对命中率的影响。</p>
</blockquote>
<p>命中率是指在程序执行过程中，CPU从缓存中成功找到所需数据的比例。高命中率通常表示程序能够有效地利用缓存，减少了对主内存的访问，从而提高了性能。以下是对命中率影响因素的更详细分析：</p>
<ol type="1">
<li><strong>Cache大小：</strong>
较大的Cache可以容纳更多的数据块，提高了可能命中的数据量。这通常导致更高的命中率，尤其是对于具有良好局部性的程序。然而，过大的Cache也可能导致性能下降，因为查找更多数据可能需要更长的时间。</li>
<li><strong>空间局部性：</strong>
空间局部性是指程序倾向于访问临近地址的数据。如果程序在一段时间内访问了某个地址，那么这个地址附近的数据可能会被加载到Cache中，提高了命中率。</li>
<li><strong>时间局部性：</strong>
时间局部性是指程序在一段时间内多次访问相同的数据。如果程序反复访问某个数据块，那么这个数据块可能一直驻留在Cache中，增加了命中率。</li>
<li><strong>缓存置换策略：</strong>
缓存中的数据块有限，当新的数据需要加载到Cache而没有足够的空间时，就需要进行缓存置换。不同的置换策略（如LRU、FIFO等）对命中率有不同的影响。</li>
<li><strong>缓存关联度：</strong>
Cache的关联度指的是某一组相邻地址映射到Cache的相同组。关联度较高的Cache有更好的空间局部性，因为相邻地址通常映射到相同的Cache组，提高了命中率。</li>
<li><strong>程序访存模式：</strong>
程序的访存模式对命中率也有影响。顺序访存和随机访存的程序可能有不同的命中率表现，因为不同的访存模式可能导致不同的局部性。</li>
</ol>
<p>总体而言，理解并优化这些因素对于提高命中率至关重要。在实际的系统设计中，通常通过模拟、分析和实验来确定最佳的Cache配置，以在性能和硬件成本之间找到平衡。</p>
<blockquote>
<p>当指令<code>Cache</code>和数据<code>Cache</code>独立实现时，如何设计顶层<code>Cache</code>的有限状态机。</p>
</blockquote>
<p>理论上，一个顶层Cache的有限状态机（FSM）可以有以下几个状态和转换：</p>
<ol type="1">
<li><strong>Idle（空闲状态）</strong>:
初始状态，等待CPU的访问请求。此状态可以分为读请求和写请求两种情况。</li>
<li><strong>ReadMiss（读缺失状态）</strong>:
当CPU发起一个读请求时，顶层Cache会检查是否存在缓存命中。如果缓存未命中，则进入该状态，等待从主内存读取所需的数据。</li>
<li><strong>WriteMiss（写缺失状态）</strong>:
当CPU发起一个写请求时，顶层Cache会检查是否存在缓存命中。如果缓存未命中，则进入该状态，等待从主内存读取所需的数据，并执行写操作。</li>
<li><strong>WriteBack（写回状态）</strong>:
当Cache中的一个缓存块被替换时，如果该缓存块需要写回主内存，则进入该状态，等待将被替换的数据写回主内存。</li>
<li><strong>AccessComplete（访问完成状态）</strong>:
当读缺失状态或写缺失状态中的数据读取完成，或者写回状态中的数据写回主内存完成时，Cache会进入该状态，并将请求的数据返回给CPU。</li>
</ol>
<p>通过在状态之间进行转换，Cache能够根据CPU的访问请求进行相应的操作，从而提供数据的快速访问，以提高命中率和整体性能。</p>
]]></content>
      <categories>
        <category>数电实验</category>
      </categories>
  </entry>
  <entry>
    <title>Lab8 单周期CPU设计</title>
    <url>/2023/11/28/%E6%95%B0%E7%94%B5%E5%AE%9E%E9%AA%8C/Lab8%20%20%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="单周期cpu设计实验报告">单周期CPU设计实验报告</h1>
<p>##实验整体方案设计</p>
<ol type="1">
<li>指令集设计：
<ul>
<li>定义一个基本的指令集，包括数据传输指令（Load、Store）、算术逻辑运算指令（Add、Subtract、AND、OR等）、控制指令（Jump、Branch等）等。</li>
<li>指令格式可以采用定长或变长，根据实验要求决定。</li>
</ul></li>
<li>寄存器设计：
<ul>
<li>设计一个包含多个通用寄存器的寄存器文件，用于存储操作数和结果。</li>
<li>寄存器文件中通常包含16个或更多的寄存器，每个寄存器的位数根据需求决定。</li>
</ul></li>
<li>控制单元设计：
<ul>
<li>控制单元负责解码指令，并发出相应的控制信号控制数据通路的操作。</li>
<li>使用组合逻辑电路或者有限状态机对指令进行解码，并根据指令类型产生相应的控制信号。</li>
</ul></li>
<li>数据通路设计：
<ul>
<li>数据通路负责执行指令中的操作，包括寄存器读写、算术逻辑运算、数据传输等。</li>
<li>数据通路包含ALU（算术逻辑单元）用于执行算术和逻辑运算，以及数据存储器用于存储数据。</li>
</ul></li>
<li>内存设计：
<ul>
<li>设计一个数据存储器用于存储程序指令和数据。</li>
<li>内存可以是一个简单的RAM或ROM，也可以是更复杂的存储器结构，根据需求和实验要求来设计。</li>
</ul></li>
<li>时钟设计：
<ul>
<li>为CPU设计一个合适的时钟信号，用于同步CPU的各个模块的操作。</li>
<li>时钟可以是固定频率的，也可以是可调节的。</li>
</ul></li>
<li>实验验证：
<ul>
<li>在设计完成后，使用合适的测试程序对CPU进行验证。</li>
<li>运行多个指令序列，验证CPU是否按照预期执行指令，并产生正确的结果。</li>
</ul></li>
</ol>
<h2 id="子模块设计">子模块设计</h2>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231130180651223.png" alt="image-20231130180651223" style="zoom:67%;" /></p>
<p>子模块按照图中要求的模块逐一实现，其中大多数模块我们之前已经实现过。</p>
<p>要注意的是数据寄存器仅仅是lab7所要求的功能是不够的，我们要实现按字节进行存取，即额外考虑地址第两位。</p>
<h3 id="控制器模块">控制器模块</h3>
<p>通过多路选择器生成cpu执行过程中所需要的控制信号。例如，extop：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ExtOp</span></span><br><span class="line"><span class="keyword">always</span>@(*)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(opcode==<span class="number">7&#x27;b0110111</span>||opcode==<span class="number">7&#x27;b0010111</span>)ExtOp=<span class="number">3&#x27;b001</span>;<span class="comment">//U</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode==<span class="number">7&#x27;b0010011</span>||opcode==<span class="number">7&#x27;b1100111</span>||opcode==<span class="number">7&#x27;b0000011</span>)ExtOp=<span class="number">3&#x27;b000</span>;<span class="comment">//I</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode==<span class="number">7&#x27;b0110011</span>)ExtOp=<span class="number">3&#x27;bxxx</span>;<span class="comment">//R</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode==<span class="number">7&#x27;b1101111</span>)ExtOp=<span class="number">3&#x27;b100</span>;<span class="comment">//J</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode==<span class="number">7&#x27;b1100011</span>)ExtOp=<span class="number">3&#x27;b011</span>;<span class="comment">//B</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode==<span class="number">7&#x27;b0100011</span>)ExtOp=<span class="number">3&#x27;b010</span>;<span class="comment">//S</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">//End</span></span><br></pre></td></tr></table></figure>
<h3 id="跳转">跳转</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @ (*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (Branch)</span><br><span class="line">            <span class="number">3&#x27;b000</span>: <span class="keyword">begin</span> NxtASrc = <span class="number">1&#x27;b0</span>; NxtBSrc = <span class="number">1&#x27;b0</span>; <span class="keyword">end</span> <span class="comment">//非跳转指令</span></span><br><span class="line">            <span class="number">3&#x27;b001</span>: <span class="keyword">begin</span> NxtASrc = <span class="number">1&#x27;b0</span>; NxtBSrc = <span class="number">1&#x27;b1</span>; <span class="keyword">end</span> <span class="comment">//jal: 无条件跳转PC目标</span></span><br><span class="line">            <span class="number">3&#x27;b010</span>: <span class="keyword">begin</span> NxtASrc = <span class="number">1&#x27;b1</span>; NxtBSrc = <span class="number">1&#x27;b1</span>; <span class="keyword">end</span> <span class="comment">//jalr: 无条件跳转寄存器目标</span></span><br><span class="line">            <span class="number">3&#x27;b100</span>: <span class="keyword">begin</span> NxtASrc = <span class="number">1&#x27;b0</span>; NxtBSrc = (zero===<span class="number">1&#x27;bx</span>)?<span class="number">1&#x27;b1</span>:zero; <span class="keyword">end</span> <span class="comment">//beq: 条件分支，等于</span></span><br><span class="line">            <span class="number">3&#x27;b101</span>: <span class="keyword">begin</span> NxtASrc = <span class="number">1&#x27;b0</span>; NxtBSrc = (zero===<span class="number">1&#x27;bx</span>)?<span class="number">1&#x27;b1</span>:~zero; <span class="keyword">end</span> <span class="comment">//bne: 条件分支，不等于</span></span><br><span class="line">            <span class="number">3&#x27;b110</span>: <span class="keyword">begin</span> NxtASrc = <span class="number">1&#x27;b0</span>; NxtBSrc = (result0===<span class="number">1&#x27;bx</span>)?<span class="number">1&#x27;b1</span>:result0; <span class="keyword">end</span> <span class="comment">//blt, bltu: 条件分支，小于</span></span><br><span class="line">            <span class="number">3&#x27;b111</span>: <span class="keyword">begin</span> NxtASrc = <span class="number">1&#x27;b0</span>; NxtBSrc = (result0===<span class="number">1&#x27;bx</span>)?<span class="number">1&#x27;b1</span>:~result0; <span class="keyword">end</span> <span class="comment">//bge, bgeu: 条件分支，大于等于</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span> NxtASrc = <span class="number">1&#x27;b0</span>; NxtBSrc = <span class="number">1&#x27;b0</span>; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="数据通路">数据通路</h3>
<p>按照原理图进行连接。需要尤其注意时序，确保指令成功写入后被取出。在写后读操作中，写入数据后，需要确保写入的数据已经被稳定保存在寄存器中，然后再进行读取。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> InstrMemclk=clock;<span class="comment">//指令 下降沿读取</span></span><br><span class="line"><span class="keyword">assign</span> DataMemrdclk=clock;<span class="comment">//数据 上升沿读取</span></span><br><span class="line"><span class="keyword">assign</span> DataMemwrclk=clock;<span class="comment">//数据 下降沿写入</span></span><br></pre></td></tr></table></figure>
<h3 id="顶层模块">顶层模块</h3>
<p>将数据通路，指令存储模块，数据存储模块连接，得到单周期CPU的完全体。</p>
<h2 id="仿真测试">仿真测试</h2>
<p>部分截图如下：</p>
<figure>
<img
src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231130182921571.png"
alt="image-20231130182921571" />
<figcaption aria-hidden="true">image-20231130182921571</figcaption>
</figure>
<h2 id="fpga验证">FPGA验证</h2>
<p>实现从1加到500，最终FPGA上呈现1e942。</p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231130183215103.png" alt="image-20231130183215103" style="zoom:13%;" /></p>
<h2 id="错误现象及分析">错误现象及分析</h2>
<ol type="1">
<li><p>时序。一定要在上升沿写，下降沿读，确保数据在寄存器中稳定存在并成功读取。</p>
<p>数据写入寄存器：</p>
<ul>
<li>在时钟信号的上升沿开始，将需要写入的数据传递到寄存器。</li>
<li>寄存器在时钟信号的上升沿稳定保存数据。</li>
</ul>
<p>数据从寄存器读取：</p>
<ul>
<li>在时钟信号的下降沿开始，将需要读取的寄存器数据传递给需要的模块（如数据通路、ALU等）。</li>
<li>模块在时钟信号的下降沿接收到稳定的数据。</li>
</ul></li>
<li><p>控制信号的生成。一定要滴水不漏。例如，仅仅通过func7[5]来判断某些控制信号可能对其他类型的指令造成干扰，因此必须考虑到所有的条件。</p></li>
</ol>
<h2 id="思考题">思考题</h2>
<blockquote>
<p><strong>分析比较运算使用独立比较器件和利用减法运算来实现的区别。</strong></p>
</blockquote>
<p>区别如下：</p>
<ul>
<li><strong>硬件复杂度：</strong>
独立比较器件是专门针对比较运算而设计的硬件组件，其电路结构被专门优化，能够在一个时钟周期内执行比较运算。而利用减法运算来实现比较运算，则需要通过ALU来进行减法运算，会引入更多的硬件逻辑。</li>
<li><strong>灵活性：</strong>
独立比较器件在设计上已经固定了比较的方式和输入输出端口，不易改变其功能。而利用减法运算来实现比较运算的方法，可以根据需要自由选择需要进行比较的数，并可以根据减法结果的判断进行后续的处理。</li>
<li><strong>性能：</strong>
独立比较器件通常能在一个时钟周期内完成比较运算，具有更高的性能。而利用减法运算来实现比较运算的方法，需要进行减法运算并判断结果，可能需要多个时钟周期才能得到比较的结果，性能上会有一定的影响。</li>
</ul>
<p>综上所述，独立比较器件在比较运算中具有简单、快速和高性能的特点，但缺乏灵活性。而利用减法运算来实现比较运算的方法则更加灵活，但可能会带来更多的硬件复杂度和性能消耗。选择使用哪种方法可以根据具体的应用需求和硬件资源来决定。</p>
<blockquote>
<p><strong>分析为什么单周期 CPU
中指令存储器的读操作必须是异步读取？</strong></p>
</blockquote>
<p>主要涉及到时序和性能方面的考虑。</p>
<ol type="1">
<li><strong>时序要求：</strong>每个指令在执行阶段都需要一个时钟周期。如果指令存储器的读操作是同步的，那么读取指令的过程可能需要多个时钟周期，这会导致指令的执行时间不一致，不符合单周期
CPU 的设计要求。</li>
<li><strong>简化设计和控制：</strong>
异步读取的设计更为简单，不需要严格的时序控制。同步读取需要考虑时钟信号的边沿以及同步时序的一致性，这增加了设计的复杂性。而异步读取不涉及时钟边沿，简化了设计和控制。</li>
<li><strong>性能优化：</strong>
异步读取可以更灵活地利用存储器的响应时间。在同步读取中，需要等待时钟信号的边沿来触发读取操作，这可能导致一些时钟周期的浪费。异步读取则可以在存储器准备好数据时立即进行读取，最大程度地利用存储器性能，提高整体性能。</li>
<li><strong>处理器与存储器速度不匹配：</strong>
处理器和存储器的速度可能不匹配，异步读取允许存储器以自己的速度响应，而不需要等待固定的时钟信号。这对于处理器和存储器速度差异较大的情况下尤为重要。</li>
</ol>
<p>总的来说，异步读取的设计简单、性能灵活，更适合单周期 CPU
的设计理念。异步读取允许指令存储器根据自身的响应时间提供数据，而不受时钟信号的限制，有利于实现一个简单且高效的单周期
CPU。</p>
<blockquote>
<p><strong>寄存器堆如何实现写后读操作？</strong></p>
</blockquote>
<ol type="1">
<li><strong>写入数据：</strong>
<ul>
<li><strong>写入地址和数据：</strong>
首先，通过控制信号将写入的目标寄存器地址和要写入的数据送入寄存器堆。</li>
<li><strong>写使能信号：</strong>
通过一个写使能信号regwr来告诉寄存器堆此时需要进行写入操作。</li>
<li><strong>时钟信号：</strong> 前半周期写。</li>
<li><strong>写入电路：</strong>
寄存器堆内部有相应的写入电路，根据写入地址和数据进行更新。</li>
</ul></li>
<li><strong>读取数据：</strong>
<ul>
<li><strong>读取地址：</strong>
通过控制信号将要读取的寄存器地址送入寄存器堆。</li>
<li><strong>读使能信号：</strong> 同时，通过一个读使能信号（Read
Enable）来告诉寄存器堆此时需要进行读取操作。</li>
<li><strong>时钟信号：</strong> 后半周期读。</li>
<li><strong>读取电路：</strong>
寄存器堆内部有相应的读取电路，根据读取地址输出相应的数据。</li>
</ul></li>
</ol>
<p>通过以上步骤，实现了写入和读取的操作。在写后读操作中，由于写操作和读操作是分离的，需要确保写操作在时钟信号的边沿完成，以保证写入的数据已经稳定存储。这样在接下来的读取操作中，可以获取到更新后的数据。</p>
<p>需要注意的是，写后读操作的实现还可能涉及一些其他的控制逻辑，以确保顺序执行写和读，并避免写和读的冲突。这包括处理写入和读取的时序关系，以及解决可能出现的竞争条件等。</p>
<blockquote>
<p><strong>思考如何实现支持 RV32M
指令集的单周期中央处理器？</strong></p>
</blockquote>
<p>要实现支持 RV32M
指令集的单周期中央处理器，需要考虑以下步骤和关键点：</p>
<ol start="2" type="1">
<li><strong>指令解码：</strong>识别不同的指令类型（R、I、U、J、S、B）并提取指令中的不同字段（如操作码、目标寄存器、源寄存器、立即数等）。</li>
<li><strong>控制信号生成：</strong>
针对每种指令，需要生成相应的控制信号，用于控制寄存器读写、ALU操作、内存访问等。</li>
<li><strong>ALU 设计：</strong> 对于 RV32M 指令集，ALU
需要支持乘法和除法运算。</li>
<li><strong>寄存器：</strong> 保存 CPU
中的寄存器值，并能够读取或写入这些寄存器。</li>
<li><strong>单周期时序：</strong>
确保所有操作都在一个时钟周期内完成。在单周期CPU中，每条指令的执行都需要一个固定的时钟周期。</li>
</ol>
]]></content>
      <categories>
        <category>数电实验</category>
      </categories>
  </entry>
  <entry>
    <title>流水线CPU设计</title>
    <url>/2023/12/05/%E6%95%B0%E7%94%B5%E5%AE%9E%E9%AA%8C/%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="流水线cpu设计">流水线CPU设计</h1>
<h2 id="实验整体方案设计">实验整体方案设计</h2>
<ul>
<li>取指 IF (Instruction Fetch)：主要完成从指令存储中读取指令的工作，
并同时计算下一个周期的 PC。</li>
<li>译码 ID (Instruction
Decode)：主要完成指令译码、立即数扩展、读取寄存器堆等的操作以及生成控制
信号。</li>
<li>执行 EX (Execution)：主要完成 ALU
运算，判断分支转移指令是否跳转等操作。</li>
<li>访存 MEM (Memory access)：主要完成对内存的读写操作。</li>
<li>写回 WB (Write Back)：主要完成将计算结果写回到寄存器中的操作。</li>
</ul>
<p>为了保存指令执行的中间结果，流水段之间有一个流水段寄存器，每个流水段寄存器用来存放从当前流水段传到后面所有流水段的信息。</p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231205104441687.png" alt="image-20231205104441687" style="zoom:57%;" /></p>
<h2 id="子模块设计">子模块设计</h2>
<h3 id="if">IF</h3>
<p>IF阶段实现PC更新和取指令。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(*)<span class="keyword">begin</span></span><br><span class="line">       NxtPC=IF_PC+<span class="number">4</span>;</span><br><span class="line">       <span class="keyword">if</span>(reset)<span class="keyword">begin</span></span><br><span class="line">           IF_PC=<span class="number">32&#x27;b0</span>;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">always</span>@(<span class="keyword">negedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">if</span>(!stallIF&amp;&amp;!reset)IF_PC&lt;=PCSrc?Branchtarget:NxtPC;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="comment">//上升沿读取指令</span></span><br><span class="line">   <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">      IF_Instr =ram[IF_PC[<span class="number">15</span>:<span class="number">2</span>]];</span><br><span class="line">   <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="id">ID</h3>
<p>ID阶段进行译码，产生控制信号，进行立即数扩展等，直接引用lab8中使用的代码即可。</p>
<h3 id="ex">EX</h3>
<p>EX阶段，利用ALU部件计算数据存储器的地址、数据，以及跳转地址。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">assign</span> flushIF=(PCSrc)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">assign</span> flushID=(PCSrc)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">wire</span> zero;<span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>]dataa;<span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>]datab;</span><br><span class="line">    <span class="keyword">assign</span> dataa=(IDEX_ALUASrc)?IDEX_PC:IDEX_rs1_data;</span><br><span class="line">    <span class="keyword">assign</span> datab=(IDEX_ALUBSrc[<span class="number">1</span>])?IDEX_imm:(IDEX_ALUBSrc[<span class="number">0</span>]?<span class="number">32&#x27;d4</span>:IDEX_rs2_data);</span><br><span class="line">    ALU32 EX_ALU32(<span class="variable">.result</span>(EX_ALUResult),<span class="variable">.zero</span>(zero),<span class="variable">.dataa</span>(dataa),<span class="variable">.datab</span>(datab),<span class="variable">.aluctr</span>(IDEX_ALUctr));</span><br><span class="line"><span class="comment">//控制冒险，跳转    </span></span><br><span class="line">    <span class="keyword">wire</span> NxtASrc;<span class="keyword">wire</span> NxtBSrc;</span><br><span class="line">    BranchControl EX_BranchControl(<span class="variable">.zero</span>(zero),<span class="variable">.result0</span>(EX_ALUResult[<span class="number">0</span>]),<span class="variable">.Branch</span>(IDEX_Branch),<span class="variable">.NxtASrc</span>(NxtASrc),<span class="variable">.NxtBSrc</span>(NxtBSrc));</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] NxtA;</span><br><span class="line">    <span class="keyword">assign</span> NxtA = NxtASrc ? IDEX_rs1_data:IDEX_PC;</span><br><span class="line">    <span class="keyword">always</span>@(*)<span class="keyword">begin</span></span><br><span class="line">        Branchtarget=(reset)?<span class="number">32&#x27;b0</span>:(NxtA+IDEX_imm); </span><br><span class="line">        PCSrc=(reset)?<span class="number">1&#x27;b0</span>:NxtBSrc;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//数据存储要用的    </span></span><br></pre></td></tr></table></figure>
<h3 id="mem">MEM</h3>
<p>MEM阶段对数据存储进行读写，与单周期类似，直接调用Datamem即可。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">DataMem MEM_DataMem(</span><br><span class="line">    <span class="variable">.dataout</span>(MEM_Out),<span class="variable">.clk</span>(clk),</span><br><span class="line">    <span class="variable">.we</span>(EXMEM_MemWr),<span class="variable">.MemOp</span>(EXMEM_MemOp),</span><br><span class="line">    <span class="variable">.datain</span>(EXMEM_in[<span class="number">15</span>:<span class="number">0</span>]),<span class="variable">.addr</span>(EXMEM_ALUResult)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<h3 id="wb">WB</h3>
<p>WB负责将最终运算结果写回到目的寄存器。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> busw=(MEMWB_MemtoReg)?MEMWB_Out:MEMWB_ALUResult;</span><br></pre></td></tr></table></figure>
<h3 id="流水段寄存器">流水段寄存器</h3>
<p>为了进行冒险处理，流水段寄存器在相邻两段之间传送数据，并把各段的处理工作相互隔离，实现暂存中间数据的功能。</p>
<p>当流水线中某个阶段暂时无法执行时，该阶段前面的所有流水段都
应该停下来等待其执行完毕再继续执行。暂停流水段的执行通常可以通过保持流水段前的段寄存器不变来实现。</p>
<p>如IF/ID段寄存器：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">negedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!stallID)IFID_PC&lt;=(flushIF)?<span class="number">0</span>:IF_PC;</span><br><span class="line">    <span class="keyword">if</span>(!stallID)IFID_Instr&lt;=(flushIF)?<span class="number">0</span>:IF_Instr;</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="冒险处理">冒险处理</h3>
<h4 id="结构冒险">结构冒险</h4>
<p>利用5段流水线，通过插入空流水段，使得每个阶段的硬件资源都只有一个指令在使用（在顶层链接各个模块即可）。</p>
<p>在寄存器堆中读
写操作分时序执行，相当于两个独立部件，牵绊周期读，后半周期写，不会出现数据读写地址冲突的情况。</p>
<h4 id="数据冒险">数据冒险</h4>
<p>指后续指令需要使用前面指令的计算结果，但是前序指令还未将数据写入寄存器时，后续指令就需要读取寄存器。简单5段流水线只考虑Read
After Write冒险。在这里我们通过插入气泡的方式进行阻塞，解决RAW冒险。</p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231205105954841.png" alt="image-20231205105954841" style="zoom:50%;" /></p>
<p>由文档描述，在MEM实现冲刷和阻塞信号的产生。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(MEMWB_rd&amp;&amp;((IDEX_rs1==EXMEM_rd)||(IDEX_rs2==EXMEM_rd))) <span class="keyword">begin</span></span><br><span class="line">            stallIF=<span class="number">1</span>;</span><br><span class="line">            stallID=<span class="number">1</span>;</span><br><span class="line">            stallEX=<span class="number">1</span>;</span><br><span class="line">            flushEX=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="控制冒险">控制冒险</h4>
<p>控制冒险指分支和跳转指令有可能改变指令执行顺序。如果前序指令中的分支和跳转不能在IF阶段就确定下一指令的具体地址，则IF阶段会继续顺序取PC+4的指令，造成指令取指错误，在真正进行跳转时需要将流水线中错误的指令冲刷掉。</p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231205110306887.png" alt="image-20231205110306887" style="zoom:50%;" /></p>
<p>在EX阶段进行指令冲刷。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> flushIF=(PCSrc)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span> flushID=(PCSrc)?<span class="number">1</span>:<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="仿真测试">仿真测试</h2>
<p>通过本地测试，部分截图：</p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231205111255674.png" alt="image-20231205111255674" style="zoom:50%;" /></p>
<p>通过官方测试集，部分截图：</p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231205111330707.png" alt="image-20231205111330707" style="zoom:50%;" /></p>
<h2 id="fpga验证">FPGA验证</h2>
<h2 id="思考题">思考题</h2>
<h3 id="如何添加中断与csr寄存器支持">如何添加中断与CSR寄存器支持</h3>
<ul>
<li>添加CSR寄存器，用于保存异常入口地址，异常原因，和当前地址等。</li>
<li>加入异常响应机制。一旦异常，就会保存当前状态和异常原因，并将pc跳转到异常入口地址。</li>
</ul>
<p>因此需要对IF阶段进行修改，实现对异常入口地址的跳转。</p>
<p>并全程添加异常监视，一旦有异常，立刻保存当前状态并更新pc。</p>
<h3 id="简述高级流水线设计方法">简述高级流水线设计方法</h3>
<h4 id="总述">总述</h4>
<p><a
href="https://cs.nju.edu.cn/swang/CompArchOrg_13F/slides/lecture26.pdf">L23
(nju.edu.cn)</a></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231205113417142.png" alt="image-20231205113417142" style="zoom:50%;" /></p>
<h4 id="arm-cortex-a9的超标量流水线">ARM Cortex-A9的超标量流水线</h4>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231205113855357.png" alt="image-20231205113855357" style="zoom:50%;" /></p>
<h4 id="core-i7的超标量流水线">Core i7的超标量流水线</h4>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231205113920449.png" alt="image-20231205113920449" style="zoom:67%;" /></p>
<h3 id="如何设计更多流水段的cpu">如何设计更多流水段的CPU</h3>
<p>流水线的级数是越大越好吗？肯定不是。级数越大，所用的流水线寄存器相应增加，单条指令的延迟增加，流水线寄存器延迟比例增加；填满流水线的指令条数更多，指令之间的关系更加复杂。</p>
<h4
id="基于bram的riscv六级流水线设计">基于BRAM的RISCV六级流水线设计</h4>
<p><a href="https://soc.ustc.edu.cn/CECS/lab3/pipeline/">流水线解读 -
USTC CECS 2023</a></p>
<p><img src="https://soc.ustc.edu.cn/CECS/lab3/pipeline.assets/image-20230816200618784.png" alt="img" style="zoom:30%;" /></p>
<p>整个流水线是基于BRAM的哈佛架构流水线处理器。主要分为以下几个流水级：</p>
<ul>
<li>IF1：取指第一阶段，pc从这里发起取指请求，并进行分支预测（目前流水线是静态预测不跳转）</li>
<li>IF2：取指第二阶段，得到ICache中的指令</li>
<li>ID：译码，得到指令的操作数、操作类型、分支类型、访存类型等信息，同时读取寄存器堆的两个源操作数。</li>
<li>EX：执行，根据指令类型进行运算，同时对分支情况进行核验。这一级也会发起对于DCache的访存请求。</li>
<li>MEM：访存，获取DCache中读取的数据，并通过地址和访存类型对数据进行移位处理。</li>
<li>WB：写回，将EX和MEM阶段的结果写回寄存器堆。</li>
</ul>
<h4 id="arm106段">ARM10(6段)</h4>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231205112421578.png" alt="image-20231205112421578" style="zoom:60%;" /></p>
<h4 id="arm119段">ARM11(9段)</h4>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231205112646728.png" alt="image-20231205112646728" style="zoom:53%;" /></p>
<p><img src="C:\Users\86199\AppData\Roaming\Typora\typora-user-images\image-20231205112728068.png" alt="image-20231205112728068" style="zoom:67%;" /></p>
]]></content>
      <categories>
        <category>数电实验</category>
      </categories>
  </entry>
</search>
